Setting JAVA_HOME to /mnt/efs/fs1/jdk1.7.0_80

Adding /mnt/efs/fs1/jdk1.7.0_80/bin: to PATH environmental variable


Java 7 environment setup completed
Closure-5
07:18:20.618 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 Failed Tests: 1
Reading method line coverage from /mnt/efs/fs1/XiaInformation/AllMethods/Closure/5.txt
Reading test line coverage from /mnt/efs/fs1/XiaInformation/LineCoverage/Closure/5.txt
07:22:30.660 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - ProFL successfully initialized
07:22:30.744 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-5/generalSusInfo.profl
07:22:30.819 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-5/aggregatedSusInfo.profl
07:22:30.825 [main] INFO edu.lu.uni.serval.bug.fixer.FixMinerFixer - =======Fixing Beginning======
07:22:30.825 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===207
07:22:31.711 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case DELPROP:
if (DELPROP == 0) {
    new IllegalArgumentException("");
}

if (DELPROP != 0) {

    
}

if (DELPROP > 0) {

    
}

07:22:31.760 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:33.110 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:33.110 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:33.480 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:33.480 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:33.797 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 

07:22:33.800 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:34.389 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:34.389 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===216
07:22:34.444 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case STRING_KEY:
if (STRING_KEY == 0) {
    new IllegalArgumentException("");
}

if (STRING_KEY != 0) {

    
}

if (STRING_KEY > 0) {

    
}

07:22:34.446 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:35.096 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:35.096 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:35.425 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:35.425 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:35.856 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 

07:22:35.857 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:36.850 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:36.850 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===228
07:22:36.982 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case OBJECTLIT:
if (OBJECTLIT == 0) {
    new IllegalArgumentException("");
}

if (OBJECTLIT != 0) {

    
}

if (OBJECTLIT > 0) {

    
}

07:22:36.984 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:37.951 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:37.952 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:38.313 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:38.314 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:38.653 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 

07:22:38.654 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:39.412 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:39.413 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Node ===1440
07:22:40.114 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return res;
if (res != null) {


}

07:22:40.119 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:41.301 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
if (res == null) {
    return null;
}

if (res == null) {
    throw new IllegalArgumentException("Empty variable: " + res);
}

07:22:41.302 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:42.395 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:42.395 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:43.399 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
detachChildren();
	return res;
return res;
	detachChildren();
setQuotedString();
	return res;
return res;
	setQuotedString();
07:22:43.401 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:44.386 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:44.387 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:45.398 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:45.398 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:46.376 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:46.377 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:47.368 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 

07:22:47.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:48.374 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:48.375 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Node ===1411
07:22:48.539 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return "Node tree inequality:" +
            "\nTree1:\n" + toStringTree() +
            "\n\nTree2:\n" + node2.toStringTree() +
            "\n\nSubtree1: " + diff.nodeA.toStringTree() +
            "\n\nSubtree2: " + diff.nodeB.toStringTree();
if (node2 != null) {


}

07:22:48.542 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:49.568 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
if (node2 == null) {
    return null;
}

if (node2 == null) {
    throw new IllegalArgumentException("Empty variable: " + node2);
}

07:22:49.570 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:50.543 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:50.544 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:51.514 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 

07:22:51.517 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:52.499 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:52.499 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===184
07:22:52.511 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case RETURN:
if (RETURN == 0) {
    new IllegalArgumentException("");
}

if (RETURN != 0) {

    
}

if (RETURN > 0) {

    
}

07:22:52.513 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:53.127 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:53.127 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:53.444 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:53.444 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:53.762 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 

07:22:53.764 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:54.360 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:54.360 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Node ===1427
07:22:54.460 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return new NodeMismatch(this, node2);
if (node2 != null) {


}

07:22:54.462 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:55.446 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
if (node2 == null) {
    return null;
}

if (node2 == null) {
    throw new IllegalArgumentException("Empty variable: " + node2);
}

07:22:55.447 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:56.418 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:56.419 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:57.454 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
addChildToFront(node2);
addChildToFront(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildToFront(node2);
addChildToBack(node2);
addChildToBack(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildToBack(node2);
addChildrenToFront(node2);
addChildrenToFront(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildrenToFront(node2);
addChildrenToBack(node2);
addChildrenToBack(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildrenToBack(node2);
removeChild(node2);
removeChild(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	removeChild(node2);
detachChildren();
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	detachChildren();
setQuotedString();
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	setQuotedString();
07:22:57.457 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:58.516 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:58.517 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:22:59.557 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:22:59.557 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:00.841 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:00.842 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:01.917 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:01.918 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:02.883 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:02.884 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:03.913 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:03.913 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:04.877 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:04.878 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:05.860 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:05.860 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:06.828 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:06.828 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:07.830 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:07.830 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:08.856 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:08.857 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:09.848 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:09.849 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:10.825 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:10.825 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:11.832 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:11.833 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:12.804 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:12.804 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:13.769 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:13.770 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:14.743 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:14.743 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:15.748 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:15.748 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:16.747 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 

07:23:16.749 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:23:17.727 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-5 ---Fixer: fix fail because of failed compiling! 
07:23:17.727 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.InlineObjectLiterals ===48
07:23:17.746 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
InlineObjectLiterals implements CompilerPass {

  public static final String VAR_PREFIX = "JSCompiler_object_inline_";

  private final AbstractCompiler compiler;

  private final Supplier<String> safeNameIdSupplier;

  InlineObjectLiterals(
      AbstractCompiler compiler,
      Supplier<String> safeNameIdSupplier) {
    this.compiler = compiler;
    this.safeNameIdSupplier = safeNameIdSupplier;
  }

  @Override
  public void process(Node externs, Node root) {
    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
        compiler, new InliningBehavior());
    callback.process(externs, root);
  }

  /**
   * Builds up information about nodes in each scope. When exiting the
   * scope, inspects all variables in that scope, and inlines any
   * that we can.
   */
  private class InliningBehavior implements Behavior {

    /**
     * A list of variables that should not be inlined, because their
     * reference information is out of sync with the state of the AST.
     */
    private final Set<Var> staleVars = Sets.newHashSet();

    @Override
    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {
      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
        Var v = it.next();

        if (isVarInlineForbidden(v)) {
          continue;
        }

        ReferenceCollection referenceInfo = referenceMap.getReferences(v);

        if (isInlinableObject(referenceInfo.references)) {
          // Blacklist the object itself, as well as any other values
          // that it refers to, since they will have been moved around.
          staleVars.add(v);

          Reference declaration = referenceInfo.references.get(0);
          Reference init = referenceInfo.getInitializingReference();

          // Split up the object into individual variables if the object
          // is never referenced directly in full.
          splitObject(v, declaration, init, referenceInfo);
        }
      }
    }

    /**
     * If there are any variable references in the given node tree,
     * blacklist them to prevent the pass from trying to inline the
     * variable. Any code modifications will have potentially made the
     * ReferenceCollection invalid.
     */
    private void blacklistVarReferencesInTree(Node root, final Scope scope) {
      NodeUtil.visitPreOrder(root, new NodeUtil.Visitor() {
        @Override
        public void visit(Node node) {
          if (node.isName()) {
            staleVars.add(scope.getVar(node.getString()));
          }
        }
      }, NodeUtil.MATCH_NOT_FUNCTION);
    }

    /**
     * Whether the given variable is forbidden from being inlined.
     */
    private boolean isVarInlineForbidden(Var var) {
      // A variable may not be inlined if:
      // 1) The variable is defined in the externs
      // 2) The variable is exported,
      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME
      // 4) A reference to the variable has been inlined. We're downstream
      //    of the mechanism that creates variable references, so we don't
      //    have a good way to update the reference. Just punt on it.

      // Additionally, exclude global variables for now.

      return var.isGlobal()
          || var.isExtern()
          || compiler.getCodingConvention().isExported(var.name)
          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)
          || staleVars.contains(var);
    }

    /**
     * Counts the number of direct (full) references to an object.
     * Specifically, we check for references of the following type:
     * <pre>
     *   x;
     *   x.fn();
     * </pre>
     */
    private boolean isInlinableObject(List<Reference> refs) {
      boolean ret = false;
      Set<String> validProperties = Sets.newHashSet();
      for (Reference ref : refs) {
        Node name = ref.getNode();
        Node parent = ref.getParent();
        Node gramps = ref.getGrandparent();

        // Ignore most indirect references, like x.y (but not x.y(),
        // since the function referenced by y might reference 'this').
        //
        if (parent.isGetProp()) {
          Preconditions.checkState(parent.getFirstChild() == name);
          // A call target may be using the object as a 'this' value.
          if (gramps.isCall()
              && gramps.getFirstChild() == parent) {
            return false;
          }

          // Deleting a property has different semantics from deleting
          // a variable, so deleted properties should not be inlined.

          // NOTE(nicksantos): This pass's object-splitting algorithm has
          // a blind spot. It assumes that if a property isn't defined on an
          // object, then the value is undefined. This is not true, because
          // Object.prototype can have arbitrary properties on it.
          //
          // We short-circuit this problem by bailing out if we see a reference
          // to a property that isn't defined on the object literal. This
          // isn't a perfect algorithm, but it should catch most cases.
          String propName = parent.getLastChild().getString();
          if (!validProperties.contains(propName)) {
            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {
              validProperties.add(propName);
            } else {
              return false;
            }
          }
          continue;
        }

        // Only rewrite VAR declarations or simple assignment statements
        if (!isVarOrAssignExprLhs(name)) {
           return false;
        }

        Node val = ref.getAssignedValue();
        if (val == null) {
          // A var with no assignment.
          continue;
        }

        // We're looking for object literal assignments only.
        if (!val.isObjectLit()) {
          return false;
        }

        // Make sure that the value is not self-referential. IOW,
        // disallow things like x = {b: x.a}.
        //
        // TODO: Only exclude unorderable self-referential
        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,
        // but x = {a: 1, b: x.a} is.
        //
        // Also, ES5 getters/setters aren't handled by this pass.
        for (Node child = val.getFirstChild(); child != null;
             child = child.getNext()) {
          if (child.isGetterDef() ||
              child.isSetterDef()) {
            // ES5 get/set not supported.
            return false;
          }

          validProperties.add(child.getString());

          Node childVal = child.getFirstChild();
          // Check if childVal is the parent of any of the passed in
          // references, as that is how self-referential assignments
          // will happen.
          for (Reference t : refs) {
            Node refNode = t.getParent();
            while (!NodeUtil.isStatementBlock(refNode)) {
              if (refNode == childVal) {
                // There's a self-referential assignment
                return false;
              }
              refNode = refNode.getParent();
            }
          }
        }


        // We have found an acceptable object literal assignment. As
        // long as there are no other assignments that mess things up,
        // we can inline.
        ret = true;
      }
      return ret;
    }

    private boolean isVarOrAssignExprLhs(Node n) {
      Node parent = n.getParent();
      return parent.isVar() ||
          (parent.isAssign()
              && parent.getFirstChild() == n
              && parent.getParent().isExprResult());
    }

    /**
     * Computes a list of ever-referenced keys in the object being
     * inlined, and returns a mapping of key name -> generated
     * variable name.
     */
    private Map<String, String> computeVarList(
        Var v, ReferenceCollection referenceInfo) {
      Map<String, String> varmap = Maps.newLinkedHashMap();

      for (Reference ref : referenceInfo.references) {
        if (ref.isLvalue() || ref.isInitializingDeclaration()) {
          Node val = ref.getAssignedValue();
          if (val != null) {
            Preconditions.checkState(val.isObjectLit());
            for (Node child = val.getFirstChild(); child != null;
                 child = child.getNext()) {
              String varname = child.getString();
              if (varmap.containsKey(varname)) {
                continue;
              }

              String var = VAR_PREFIX + varname + "_" +
                safeNameIdSupplier.get();
              varmap.put(varname, var);
            }
          }
        } else if (ref.getParent().isVar()) {
          // This is the var. There is no value.
        } else {
          Node getprop = ref.getParent();
          Preconditions.checkState(getprop.isGetProp());

          // The key being looked up in the original map.
          String varname = getprop.getLastChild().getString();
          if (varmap.containsKey(varname)) {
            continue;
          }

          String var = VAR_PREFIX + varname + "_" + safeNameIdSupplier.get();
          varmap.put(varname, var);
        }
      }

      return varmap;
    }

    /**
     * Populates a map of key names -> initial assigned values. The
     * object literal these are being pulled from is invalidated as
     * a result.
     */
    private void fillInitialValues(Reference init, Map<String, Node> initvals) {
      Node object = init.getAssignedValue();
      Preconditions.checkState(object.isObjectLit());
      for (Node key = object.getFirstChild(); key != null;
           key = key.getNext()) {
        initvals.put(key.getString(), key.removeFirstChild());
      }
    }

    /**
     * Replaces an assignment like x = {...} with t1=a,t2=b,t3=c,true.
     * Note that the resulting expression will always evaluate to
     * true, as would the x = {...} expression.
     */
    private void replaceAssignmentExpression(Var v, Reference ref,
                                             Map<String, String> varmap) {
      // Compute all of the assignments necessary
      List<Node> nodes = Lists.newArrayList();
      Node val = ref.getAssignedValue();
      blacklistVarReferencesInTree(val, v.scope);
      Preconditions.checkState(val.isObjectLit());
      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());
      for (Node key = val.getFirstChild(); key != null;
           key = key.getNext()) {
        String var = key.getString();
        Node value = key.removeFirstChild();
        // TODO(user): Copy type information.
        nodes.add(
            IR.assign(
                IR.name(varmap.get(var)),
                value));
        all.remove(var);
      }

      // TODO(user): Better source information.
      for (String var : all) {
        nodes.add(
            IR.assign(
                IR.name(varmap.get(var)),
                NodeUtil.newUndefinedNode(null)));
      }

      Node replacement;
      if (nodes.isEmpty()) {
        replacement = IR.trueNode();
      } else {
        // All assignments evaluate to true, so make sure that the
        // expr statement evaluates to true in case it matters.
        nodes.add(IR.trueNode());

        // Join these using COMMA.  A COMMA node must have 2 children, so we
        // create a tree. In the tree the first child be the COMMA to match
        // the parser, otherwise tree equality tests fail.
        nodes = Lists.reverse(nodes);
        replacement = new Node(Token.COMMA);
        Node cur = replacement;
        int i;
        for (i = 0; i < nodes.size() - 2; i++) {
          cur.addChildToFront(nodes.get(i));
          Node t = new Node(Token.COMMA);
          cur.addChildToFront(t);
          cur = t;
        }
        cur.addChildToFront(nodes.get(i));
        cur.addChildToFront(nodes.get(i + 1));
      }

      Node replace = ref.getParent();
      replacement.copyInformationFromForTree(replace);

      if (replace.isVar()) {
        replace.getParent().replaceChild(
            replace, NodeUtil.newExpr(replacement));
      } else {
        replace.getParent().replaceChild(replace, replacement);
      }
    }

    /**
     * Splits up the object literal into individual variables, and
     * updates all uses.
     */
    private void splitObject(Var v, Reference declaration,
                             Reference init,
                             ReferenceCollection referenceInfo) {
      // First figure out the FULL set of possible keys, so that they
      // can all be properly set as necessary.
      Map<String, String> varmap = computeVarList(v, referenceInfo);

      Map<String, Node> initvals = Maps.newHashMap();
      // Figure out the top-level of the var assign node. If it's a plain
      // ASSIGN, then there's an EXPR_STATEMENT above it, if it's a
      // VAR then it should be directly replaced.
      Node vnode;
      boolean defined = referenceInfo.isWellDefined() &&
          init.getParent().isVar();
      if (defined) {
        vnode = init.getParent();
        fillInitialValues(init, initvals);
      } else {
        // TODO(user): More test / rewrite this part.
        // Find the beginning of the function / script.
        vnode = v.getScope().getRootNode().getLastChild().getFirstChild();
      }

      for (Map.Entry<String, String> entry : varmap.entrySet()) {
        Node val = initvals.get(entry.getKey());
        Node varnode = NodeUtil.newVarNode(entry.getValue(), val);
        if (val == null) {
          // is this right?
          varnode.copyInformationFromForTree(vnode);
        } else {
          blacklistVarReferencesInTree(val, v.scope);
        }
        vnode.getParent().addChildBefore(varnode, vnode);
      }

      if (defined) {
        vnode.getParent().removeChild(vnode);
      }

      for (Reference ref : referenceInfo.references) {
        // The init/decl have already been converted.
        if (defined && ref == init) continue;

        if (ref.isLvalue()) {
          // Assignments have to be handled specially, since they
          // expand out into multiple assignments.
          replaceAssignmentExpression(v, ref, varmap);
        } else if (ref.getParent().isVar()) {
          // The old variable declaration. It didn't have a
          // value. Remove it entirely as it should now be unused.
          ref.getGrandparent().removeChild(ref.getParent());
        } else {
          // Make sure that the reference is a GETPROP as we expect it to be.
          Node getprop = ref.getParent();
          Preconditions.checkState(getprop.isGetProp());

          // The key being looked up in the original map.
          String var = getprop.getChildAtIndex(1).getString();

          // If the variable hasn't already been declared, add an empty
          // declaration near all the other declarations.
          Preconditions.checkState(varmap.containsKey(var));

          // Replace the GETPROP node with a NAME.
          Node replacement = IR.name(varmap.get(var));
          replacement.copyInformationFrom(getprop);
          ref.getGrandparent().replaceChild(ref.getParent(), replacement);
        }
      }

      compiler.reportCodeChange();
    }
  }
}
