Setting JAVA_HOME to /mnt/efs/fs1/jdk1.7.0_80

Adding /mnt/efs/fs1/jdk1.7.0_80/bin: to PATH environmental variable


Java 7 environment setup completed
Closure-74
19:14:04.614 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 Failed Tests: 3
Reading method line coverage from /mnt/efs/fs1/XiaInformation/AllMethods/Closure/74.txt
Reading test line coverage from /mnt/efs/fs1/XiaInformation/LineCoverage/Closure/74.txt
19:17:40.064 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - ProFL successfully initialized
19:17:41.019 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-74/generalSusInfo.profl
19:17:41.094 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-74/aggregatedSusInfo.profl
19:17:41.100 [main] INFO edu.lu.uni.serval.bug.fixer.FixMinerFixer - =======Fixing Beginning======
19:17:41.100 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1061
19:17:51.147 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return n;
if (n != null) {


}

19:17:51.163 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:17:52.850 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (n == null) {
    return null;
}

if (n == null) {
    throw new IllegalArgumentException("Empty variable: " + n);
}

19:17:52.851 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:17:55.585 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:17:55.586 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:17:56.714 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
tryReduceOperandsForOp(n);
tryReduceOperandsForOp(n);
	return n;
return n;
	tryReduceOperandsForOp(n);
tryConvertOperandsToNumber(n);
tryConvertOperandsToNumber(n);
	return n;
return n;
	tryConvertOperandsToNumber(n);
tryConvertToNumber(n);
tryConvertToNumber(n);
	return n;
return n;
	tryConvertToNumber(n);
19:17:56.717 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:17:57.717 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:17:57.718 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:17:58.680 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:17:58.681 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:17:59.661 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:17:59.661 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:00.670 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:00.671 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:01.630 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:01.630 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:02.592 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:02.592 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:03.554 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:03.554 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:04.573 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:04.574 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:05.759 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:18:05.761 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:07.097 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:07.098 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===941
19:18:07.265 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
break;

19:18:07.269 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:08.285 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:08.286 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===940
19:18:08.353 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
result = lhType != rhType;
if (lhType == 0) {
    new IllegalArgumentException("");
}

if (lhType != 0) {

    
}

if (lhType > 0) {

    
}

if (rhType == 0) {
    new IllegalArgumentException("");
}

if (rhType != 0) {

    
}

if (rhType > 0) {

    
}

19:18:08.356 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:09.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:09.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:10.367 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:10.368 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:11.421 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:11.421 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:12.816 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:12.817 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:13.952 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:13.952 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:14.976 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

            break;
	result = lhType != rhType;

MOVE-BUGGY-STATEMENT
19:18:14.977 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:16.002 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:18:16.003 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:17.081 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:17.081 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===930
19:18:17.132 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return n;
if (n != null) {


}

19:18:17.134 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:20.284 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (n == null) {
    return null;
}

if (n == null) {
    throw new IllegalArgumentException("Empty variable: " + n);
}

19:18:20.293 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:22.043 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:22.043 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:23.044 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
tryReduceOperandsForOp(n);
tryReduceOperandsForOp(n);
	return n;
return n;
	tryReduceOperandsForOp(n);
tryConvertOperandsToNumber(n);
tryConvertOperandsToNumber(n);
	return n;
return n;
	tryConvertOperandsToNumber(n);
tryConvertToNumber(n);
tryConvertToNumber(n);
	return n;
return n;
	tryConvertToNumber(n);
19:18:23.046 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:24.023 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:24.024 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:25.005 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:25.005 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:26.226 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:26.226 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:27.597 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:27.598 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:28.757 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:28.758 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:29.728 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:29.729 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:30.748 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:30.748 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:31.824 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:31.824 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:32.803 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:18:32.804 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:33.861 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:33.862 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1133
19:18:33.927 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return !equivalent;

19:18:33.932 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:35.348 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:35.349 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.NodeUtil ===2131
19:18:35.691 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case Token.SHNE:

19:18:35.697 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:36.735 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:36.735 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1131
19:18:36.789 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return equivalent;

19:18:36.792 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:37.789 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:37.789 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1027
19:18:37.905 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
break;

19:18:37.908 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:39.211 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:39.212 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1026
19:18:39.252 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
result = compareToUndefined(left, op);
result = compareToUndefined(true, left, op);
result = compareToUndefined(false, left, op);
result = compareToUndefined(left, true, op);
result = compareToUndefined(left, false, op);
result = compareToUndefined(left, op, true);
result = compareToUndefined(left, op, false);
19:18:39.255 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:40.226 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:40.227 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:41.230 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:41.230 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:42.193 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:42.194 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:43.157 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:43.158 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:44.188 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:44.188 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:45.129 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (left != null) {


}

19:18:45.132 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:46.075 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (left == null) {
    return null;
}

if (left == null) {
    throw new IllegalArgumentException("Empty variable: " + left);
}

19:18:46.077 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:47.043 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:47.043 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:48.020 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (op == 0) {
    new IllegalArgumentException("");
}

if (op != 0) {

    
}

if (op > 0) {

    
}

19:18:48.021 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:49.002 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:49.003 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:49.984 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:49.985 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:51.011 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

          break;
	result = compareToUndefined(left, op);

MOVE-BUGGY-STATEMENT
19:18:51.013 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:52.383 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:18:52.384 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:53.403 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:53.403 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===990
19:18:53.443 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return n;
if (n != null) {


}

19:18:53.445 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:54.874 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (n == null) {
    return null;
}

if (n == null) {
    throw new IllegalArgumentException("Empty variable: " + n);
}

19:18:54.875 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:55.889 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:55.889 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:56.893 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
tryReduceOperandsForOp(n);
tryReduceOperandsForOp(n);
	return n;
return n;
	tryReduceOperandsForOp(n);
tryConvertOperandsToNumber(n);
tryConvertOperandsToNumber(n);
	return n;
return n;
	tryConvertOperandsToNumber(n);
tryConvertToNumber(n);
tryConvertToNumber(n);
	return n;
return n;
	tryConvertToNumber(n);
19:18:56.894 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:57.891 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:57.891 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:18:59.068 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:18:59.069 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:00.355 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:00.356 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:01.325 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:01.325 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:02.288 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:02.288 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:03.256 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:03.257 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:04.232 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:04.233 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:05.239 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:05.240 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:06.239 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:06.240 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:07.245 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:07.246 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===925
19:19:07.285 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
break;

19:19:07.287 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:08.266 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:08.267 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===924
19:19:08.309 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
result = compareToUndefined(left, op);
result = compareToUndefined(true, left, op);
result = compareToUndefined(false, left, op);
result = compareToUndefined(left, true, op);
result = compareToUndefined(left, false, op);
result = compareToUndefined(left, op, true);
result = compareToUndefined(left, op, false);
19:19:08.311 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:09.309 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:09.309 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:10.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:10.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:11.337 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:11.337 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:12.732 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:12.733 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:13.935 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:13.936 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:14.942 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (left != null) {


}

19:19:14.944 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:15.984 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (left == null) {
    return null;
}

if (left == null) {
    throw new IllegalArgumentException("Empty variable: " + left);
}

19:19:15.986 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:16.978 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:16.979 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:17.972 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (op == 0) {
    new IllegalArgumentException("");
}

if (op != 0) {

    
}

if (op > 0) {

    
}

19:19:17.973 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:18.987 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:18.988 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:20.020 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:20.020 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:21.019 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

          break;
	result = compareToUndefined(left, op);

MOVE-BUGGY-STATEMENT
19:19:21.020 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:21.991 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:21.992 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:22.989 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:22.989 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===918
19:19:23.026 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
break;

19:19:23.029 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:24.029 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:24.030 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===916
19:19:24.067 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
result = compareToUndefined(right, op);
result = compareToUndefined(true, right, op);
result = compareToUndefined(false, right, op);
result = compareToUndefined(right, true, op);
result = compareToUndefined(right, false, op);
result = compareToUndefined(right, op, true);
result = compareToUndefined(right, op, false);
19:19:24.068 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:25.040 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:25.040 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:26.048 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:26.048 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:27.100 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:27.101 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:28.108 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:28.109 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:29.102 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:29.103 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:30.152 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (right != null) {


}

19:19:30.154 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:31.193 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (right == null) {
    return null;
}

if (right == null) {
    throw new IllegalArgumentException("Empty variable: " + right);
}

19:19:31.194 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:32.190 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:32.190 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:33.167 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (op == 0) {
    new IllegalArgumentException("");
}

if (op != 0) {

    
}

if (op > 0) {

    
}

19:19:33.168 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:34.184 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:34.184 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:35.214 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:35.214 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:36.241 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
result = compareToUndefined(right, op);
	return n;
        } else {
          
null
19:19:36.243 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:37.221 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:37.222 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:38.255 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:38.256 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===913
19:19:38.293 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!undefinedRight) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!result) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
19:19:38.295 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:39.287 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:39.287 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:40.293 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
	return n;
        } else 
null
19:19:40.296 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:41.274 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:41.275 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:42.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:42.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===911
19:19:42.408 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (left != null) {


}

19:19:42.410 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:42.770 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (left == null) {
    return null;
}

if (left == null) {
    throw new IllegalArgumentException("Empty variable: " + left);
}

19:19:42.771 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:43.776 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:43.777 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:44.769 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

        break;
	if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }

MOVE-BUGGY-STATEMENT
19:19:44.771 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:45.743 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:45.744 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:46.696 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:46.697 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===319
19:19:46.710 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case FALSE:
if (FALSE == 0) {
    new IllegalArgumentException("");
}

if (FALSE != 0) {

    
}

if (FALSE > 0) {

    
}

19:19:46.712 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:47.315 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:47.315 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:47.649 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:47.650 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:47.972 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:47.974 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:48.608 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:48.608 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===301
19:19:48.618 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case NOT:
if (NOT == 0) {
    new IllegalArgumentException("");
}

if (NOT != 0) {

    
}

if (NOT > 0) {

    
}

19:19:48.620 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:49.216 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:49.216 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:49.569 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:49.569 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:49.909 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:49.910 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:50.530 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:50.530 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===287
19:19:50.540 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case EQ:
if (EQ == 0) {
    new IllegalArgumentException("");
}

if (EQ != 0) {

    
}

if (EQ > 0) {

    
}

19:19:50.541 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:51.140 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:51.140 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:51.463 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:51.464 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:51.792 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:19:51.793 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:52.411 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:52.411 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1034
19:19:52.451 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
break;

19:19:52.453 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:53.455 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:53.456 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1033
19:19:53.512 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
result = compareToUndefined(right, op);
result = compareToUndefined(true, right, op);
result = compareToUndefined(false, right, op);
result = compareToUndefined(right, true, op);
result = compareToUndefined(right, false, op);
result = compareToUndefined(right, op, true);
result = compareToUndefined(right, op, false);
19:19:53.513 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:54.493 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:54.494 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:55.515 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:55.516 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:56.521 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:56.522 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:57.511 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:57.511 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:58.510 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:19:58.511 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:19:59.452 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (right != null) {


}

19:19:59.453 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:00.464 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (right == null) {
    return null;
}

if (right == null) {
    throw new IllegalArgumentException("Empty variable: " + right);
}

19:20:00.465 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:01.453 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:01.454 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:02.404 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (op == 0) {
    new IllegalArgumentException("");
}

if (op != 0) {

    
}

if (op > 0) {

    
}

19:20:02.405 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:03.348 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:03.349 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:04.294 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:04.294 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:05.252 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

            break;
	result = compareToUndefined(right, op);

MOVE-BUGGY-STATEMENT
19:20:05.254 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:06.188 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:20:06.189 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:07.123 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:07.123 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===958
19:20:07.160 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
break;

19:20:07.162 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:08.149 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:08.150 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===936
19:20:08.195 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
break;

19:20:08.198 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:09.208 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:09.208 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===935
19:20:09.245 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
result = lhType == rhType;
if (lhType == 0) {
    new IllegalArgumentException("");
}

if (lhType != 0) {

    
}

if (lhType > 0) {

    
}

if (rhType == 0) {
    new IllegalArgumentException("");
}

if (rhType != 0) {

    
}

if (rhType > 0) {

    
}

19:20:09.248 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:10.280 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:10.281 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:10.625 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:10.625 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:10.960 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:10.960 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:11.952 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:11.952 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:12.314 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:12.315 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:12.650 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

            break;
	result = lhType == rhType;

MOVE-BUGGY-STATEMENT
19:20:12.652 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:13.617 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:20:13.618 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:14.591 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:14.592 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===932
19:20:14.627 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
if (op == 0) {
    new IllegalArgumentException("");
}

if (op != 0) {

    
}

if (op > 0) {

    
}

19:20:14.628 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:15.592 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:15.593 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:15.955 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:15.955 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:16.297 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
	if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        
null
switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
	if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        
null

        break;
	switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }

MOVE-BUGGY-STATEMENT
19:20:16.299 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:17.261 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:17.261 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:18.233 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:18.233 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:19.213 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:20:19.214 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:20.254 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:20.254 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===927
19:20:20.303 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            rhType != Token.FALSE || rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE || rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType == Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            rhType == Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType == Token.NULL) {
          return n;
        }
19:20:20.305 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:21.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:21.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:22.343 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:22.344 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:23.395 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:23.395 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:24.377 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:24.377 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:25.370 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (lhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (op != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            lhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            op != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            lhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            op != Token.NULL) {
          return n;
        }
19:20:25.372 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:26.353 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:26.354 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:27.359 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:27.359 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:28.340 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:28.341 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:29.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:29.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:30.304 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:30.305 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:31.312 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (rhType == 0) {
    new IllegalArgumentException("");
}

if (rhType != 0) {

    
}

if (rhType > 0) {

    
}

if (rhType == 0) {
    new IllegalArgumentException("");
}

if (rhType != 0) {

    
}

if (rhType > 0) {

    
}

if (rhType == 0) {
    new IllegalArgumentException("");
}

if (rhType != 0) {

    
}

if (rhType > 0) {

    
}

19:20:31.314 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:32.354 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:32.354 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:33.365 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:33.366 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:34.342 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:34.342 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:35.323 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:35.324 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:36.303 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:36.303 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:37.267 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:37.267 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:38.263 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:38.264 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:39.270 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:39.270 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:40.294 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
	if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        
null

        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
	if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }

MOVE-BUGGY-STATEMENT

        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;
	if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }

MOVE-BUGGY-STATEMENT
19:20:40.295 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:41.274 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:41.274 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:42.245 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:42.246 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:43.202 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:20:43.203 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:44.201 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:44.202 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1137
19:20:44.235 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return !valueUndefined;

19:20:44.238 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:45.177 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:45.177 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===1135
19:20:45.223 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return valueUndefined;

19:20:45.227 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:46.197 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:46.197 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===909
19:20:46.235 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
if (lhType == 0) {
    new IllegalArgumentException("");
}

if (lhType != 0) {

    
}

if (lhType > 0) {

    
}

19:20:46.237 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:47.203 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:47.203 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:48.149 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:48.149 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:49.183 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
	if (!NodeUtil.isLiteralValue(left, false) ||
        !NodeUtil.isLiteralValue(right, false)) {
      // We only handle non-literal operands for LT and GT.
      if (n.getType() != Token.GT && n.getType() != Token.LT) {
        return n;
      }
    }

    int op = n.getType();
    boolean result;

    // TODO(johnlenz): Use the JSType to compare nodes of different types.

    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType()
          && right.getString().equals("undefined"))
          || (Token.VOID == right.getType()
              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    
null
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
	int op = n.getType();
    boolean result;

    // TODO(johnlenz): Use the JSType to compare nodes of different types.

    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType()
          && right.getString().equals("undefined"))
          || (Token.VOID == right.getType()
              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    
null
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
	boolean result;

    // TODO(johnlenz): Use the JSType to compare nodes of different types.

    boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType()
          && right.getString().equals("undefined"))
          || (Token.VOID == right.getType()
              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    
null
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
	boolean rightLiteral = NodeUtil.isLiteralValue(right, false);
    boolean undefinedRight = ((Token.NAME == right.getType()
          && right.getString().equals("undefined"))
          || (Token.VOID == right.getType()
              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    
null
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
	boolean undefinedRight = ((Token.NAME == right.getType()
          && right.getString().equals("undefined"))
          || (Token.VOID == right.getType()
              && NodeUtil.isLiteralValue(right.getFirstChild(), false)));
    int lhType = left.getType();
    int rhType = right.getType();
    
null
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
	int lhType = left.getType();
    int rhType = right.getType();
    
null
switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
	int rhType = right.getType();
    
null


    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
	switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }

MOVE-BUGGY-STATEMENT


    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
	switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }

MOVE-BUGGY-STATEMENT


    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();
	switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }

MOVE-BUGGY-STATEMENT


    Node newNode = new Node(result ? Token.TRUE : Token.FALSE);
    n.getParent().replaceChild(n, newNode);
    reportCodeChange();

    return newNode;
	switch (lhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }

MOVE-BUGGY-STATEMENT
19:20:49.185 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:50.197 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:50.198 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:51.159 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:51.160 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:52.124 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:52.125 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:53.093 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:53.093 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:54.029 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:54.029 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:55.009 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:55.009 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:55.960 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:55.961 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:56.908 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:56.908 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:57.884 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:57.885 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:58.843 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:20:58.843 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:20:59.808 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:20:59.809 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:00.779 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:00.779 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.PeepholeFoldConstants ===908
19:21:00.828 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
int rhType = right.getType();

double rhType = right.getType();
float rhType = right.getType();
long rhType = right.getType();
short rhType = right.getType();
byte rhType = right.getType();
19:21:00.830 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:01.763 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:01.764 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:02.712 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:02.712 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:03.664 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:03.664 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:04.603 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:04.604 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:05.602 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
int rhType = right.getLineno();
int rhType = right.getCharno();
int rhType = right.getSourcePosition();
int rhType = right.getChildCount();
int rhType = right.getSideEffectFlags();
19:21:05.663 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:06.621 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:06.622 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:07.570 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:07.570 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:08.557 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:08.557 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:09.517 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:09.517 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:10.465 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
int rhType = right.getType(rhType);
int rhType = right.getType(lhType);
int rhType = right.getType(undefinedRight);
int rhType = right.getType(rightLiteral);
int rhType = right.getType(result);
int rhType = right.getType(op);
int rhType = right.getType(n);
int rhType = right.getType(left);
int rhType = right.getType(INVALID_GETELEM_INDEX_ERROR);
int rhType = right.getType(INDEX_OUT_OF_BOUNDS_ERROR);
int rhType = right.getType(NEGATING_A_NON_NUMBER_ERROR);
int rhType = right.getType(BITWISE_OPERAND_OUT_OF_RANGE);
int rhType = right.getType(SHIFT_AMOUNT_OUT_OF_BOUNDS);
int rhType = right.getType(FRACTIONAL_BITWISE_OPERAND);
int rhType = right.getType(MAX_FOLD_NUMBER);
int rhType = right.getType(ROOT_LOCALE);
19:21:10.467 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:11.437 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:11.437 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:12.444 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:12.445 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:13.413 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:13.414 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:14.404 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:14.405 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:15.415 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:15.416 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:16.407 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:16.408 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:17.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:17.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:18.368 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:18.368 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:19.372 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:19.373 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:20.343 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:20.343 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:21.376 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:21.376 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:22.328 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:22.328 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:23.376 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:23.377 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:24.393 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:24.393 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:25.389 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:25.390 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:26.396 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
int rhType = rhType.getType();
int rhType = lhType.getType();
int rhType = undefinedRight.getType();
int rhType = rightLiteral.getType();
int rhType = result.getType();
int rhType = op.getType();
int rhType = n.getType();
int rhType = left.getType();
int rhType = INVALID_GETELEM_INDEX_ERROR.getType();
int rhType = INDEX_OUT_OF_BOUNDS_ERROR.getType();
int rhType = NEGATING_A_NON_NUMBER_ERROR.getType();
int rhType = BITWISE_OPERAND_OUT_OF_RANGE.getType();
int rhType = SHIFT_AMOUNT_OUT_OF_BOUNDS.getType();
int rhType = FRACTIONAL_BITWISE_OPERAND.getType();
int rhType = MAX_FOLD_NUMBER.getType();
int rhType = ROOT_LOCALE.getType();
19:21:26.398 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:27.374 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:27.375 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:28.331 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:28.331 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:29.307 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:29.307 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:30.290 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:30.290 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:31.242 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:31.243 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:32.211 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:32.212 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:33.218 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:33.218 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:34.249 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:34.250 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:35.238 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:35.238 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:36.234 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:36.234 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:37.232 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:37.233 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:38.186 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:38.187 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:39.200 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:39.201 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:40.179 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:40.180 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:41.158 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:41.159 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:42.168 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (right != null) {


}

19:21:42.169 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:43.130 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (right == null) {
    return null;
}

if (right == null) {
    throw new IllegalArgumentException("Empty variable: " + right);
}

19:21:43.131 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:44.121 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:44.122 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:45.076 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 

19:21:45.078 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:46.104 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
return left;
return right;
19:21:46.105 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:47.119 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:47.119 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:48.082 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
undefinedRight = lhType != rhType;
rightLiteral = lhType != rhType;
result = rhType != rhType;
result = op != rhType;
result = lhType != op;
19:21:48.085 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:49.146 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:49.147 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:50.166 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:50.167 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:51.146 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:51.147 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:52.157 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:52.158 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:53.160 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
return left;
return right;
19:21:53.162 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:54.157 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:54.157 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:55.108 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
return !valueNull;
return !valueUndefined;
19:21:55.110 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:56.089 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:56.089 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:57.091 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
return valueNull;
return valueUndefined;
19:21:57.094 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:58.074 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:58.075 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:59.037 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
undefinedRight = compareToUndefined(left, op);
rightLiteral = compareToUndefined(left, op);
19:21:59.040 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:21:59.995 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:21:59.996 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:00.997 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
return left;
return right;
19:22:00.999 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:01.999 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:01.999 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:02.995 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
undefinedRight = compareToUndefined(left, op);
rightLiteral = compareToUndefined(left, op);
19:22:02.997 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:03.975 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:03.976 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:04.976 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
undefinedRight = compareToUndefined(right, op);
rightLiteral = compareToUndefined(right, op);
19:22:04.979 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:05.937 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:05.938 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:06.954 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (!undefinedRight) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!result) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
19:22:06.955 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:07.940 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:07.940 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:08.908 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (!NodeUtil.isLiteralValue(rhType, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(lhType, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(undefinedRight, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(rightLiteral, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(result, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(op, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(n, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(right, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(INVALID_GETELEM_INDEX_ERROR, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(INDEX_OUT_OF_BOUNDS_ERROR, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(NEGATING_A_NON_NUMBER_ERROR, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(BITWISE_OPERAND_OUT_OF_RANGE, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(SHIFT_AMOUNT_OUT_OF_BOUNDS, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(FRACTIONAL_BITWISE_OPERAND, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(MAX_FOLD_NUMBER, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(ROOT_LOCALE, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), rhType, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), lhType, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), undefinedRight, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), rightLiteral, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), result, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), op, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), n, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), left, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), right, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), INVALID_GETELEM_INDEX_ERROR, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), INDEX_OUT_OF_BOUNDS_ERROR, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), NEGATING_A_NON_NUMBER_ERROR, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), BITWISE_OPERAND_OUT_OF_RANGE, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), SHIFT_AMOUNT_OUT_OF_BOUNDS, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), FRACTIONAL_BITWISE_OPERAND, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), MAX_FOLD_NUMBER, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), ROOT_LOCALE, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, rhType)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, lhType)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, undefinedRight)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, rightLiteral)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, result)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, op)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, n)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, left)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, right)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, INVALID_GETELEM_INDEX_ERROR)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, INDEX_OUT_OF_BOUNDS_ERROR)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, NEGATING_A_NON_NUMBER_ERROR)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, BITWISE_OPERAND_OUT_OF_RANGE)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, SHIFT_AMOUNT_OUT_OF_BOUNDS)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, FRACTIONAL_BITWISE_OPERAND)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, MAX_FOLD_NUMBER)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, ROOT_LOCALE)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(true, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(false, left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), true)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild())) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), true, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, true)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.isLiteralValue(left.getFirstChild(), false, false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
if (!NodeUtil.mayBeString(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
19:22:08.971 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:09.969 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:09.969 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:10.937 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:10.937 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:11.919 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:11.920 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:12.905 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:12.906 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:13.890 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:13.891 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:14.850 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:14.851 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:15.839 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:15.840 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:16.841 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:16.842 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:17.826 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:17.827 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:18.810 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:18.811 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:19.798 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:19.799 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:20.824 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:20.824 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:21.819 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:21.819 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:22.804 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:22.805 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:23.802 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:23.802 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:24.795 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:24.796 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:25.804 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:25.805 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:26.789 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:26.790 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:27.787 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:27.788 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:28.762 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:28.763 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:29.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:29.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:30.698 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:30.699 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:31.662 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:31.663 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:32.633 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:32.633 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:33.634 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:33.635 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:34.618 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:34.618 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:35.575 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:35.575 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:36.566 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:36.567 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:37.528 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:37.529 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:38.486 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:38.487 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:39.429 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:39.430 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:40.402 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:40.403 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:41.350 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:41.351 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:42.333 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:42.334 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:43.281 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:43.281 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:44.240 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:44.241 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:45.176 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:45.177 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:46.121 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:46.121 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:47.092 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:47.093 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:48.043 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:48.044 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:48.999 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:49.000 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:49.931 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:49.932 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:50.898 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:50.899 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:51.864 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:51.865 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:52.829 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:52.829 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:53.789 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:53.790 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:54.754 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:54.754 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:55.774 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:55.775 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:56.752 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:56.753 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:57.705 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:57.706 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:58.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:58.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:22:59.684 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:22:59.685 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:00.657 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:00.657 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:01.595 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:01.595 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:02.529 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:02.530 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:03.524 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:03.525 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:04.500 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:04.501 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:05.464 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:05.464 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:06.444 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:06.445 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:07.394 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
undefinedLeft = compareToUndefined(right, op);
undefinedRight = compareToUndefined(right, op);
rightLiteral = compareToUndefined(right, op);
19:23:07.397 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:08.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:08.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:09.337 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:09.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:10.282 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
undefinedRight = lhType == rhType;
rightLiteral = lhType == rhType;
result = rhType == rhType;
result = op == rhType;
result = lhType == op;
19:23:10.285 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:11.219 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:11.220 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:12.172 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:12.172 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:13.149 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:13.149 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:14.137 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:14.137 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:15.104 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
switch (rhType) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
switch (lhType) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
19:23:15.106 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:16.097 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:16.098 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:17.093 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
if (lhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (op != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            lhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            op != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            lhType != Token.NULL) {
          return n;
        }
if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            op != Token.NULL) {
          return n;
        }
19:23:17.095 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:18.058 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:18.058 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:19.031 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:19.032 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:19.985 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:19.985 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:20.945 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:20.946 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:21.913 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:21.913 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:22.893 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
return !equivalent;
return !valueNull;
19:23:22.895 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:23.886 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:23.887 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:24.867 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
return equivalent;
return valueNull;
19:23:24.868 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:25.828 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:25.829 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:26.788 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
switch (rhType) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
switch (op) {
      case Token.VOID:
        if (!NodeUtil.isLiteralValue(left.getFirstChild(), false)) {
          return n;
        } else if (!rightLiteral) {
          return n;
        } else {
          result = compareToUndefined(right, op);
        }
        break;

      case Token.NULL:
      case Token.TRUE:
      case Token.FALSE:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (rhType != Token.TRUE &&
            rhType != Token.FALSE &&
            rhType != Token.NULL) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = lhType == rhType;
            break;

          case Token.SHNE:
          case Token.NE:
            result = lhType != rhType;
            break;

          case Token.GE:
          case Token.LE:
          case Token.GT:
          case Token.LT:
            Boolean compareResult = compareAsNumbers(op, left, right);
            if (compareResult != null) {
              result = compareResult;
            } else {
              return n;
            }
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.THIS:
        if (right.getType() != Token.THIS) {
          return n;
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = true;
            break;

          case Token.SHNE:
          case Token.NE:
            result = false;
            break;

          // We can only handle == and != here.
          // GT, LT, GE, LE depend on the type of "this" and how it will
          // be converted to number.  The results are different depending on
          // whether it is a string, NaN or other number value.
          default:
            return n;
        }
        break;

      case Token.STRING:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.STRING != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        switch (op) {
          case Token.SHEQ:
          case Token.EQ:
            result = left.getString().equals(right.getString());
            break;

          case Token.SHNE:
          case Token.NE:
            result = !left.getString().equals(right.getString());
            break;

          default:
            return n;  // we only handle == and != here
        }
        break;

      case Token.NUMBER:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }
        if (Token.NUMBER != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        Boolean compareResult = compareAsNumbers(op, left, right);
        if (compareResult != null) {
          result = compareResult;
        } else {
          return null;
        }
        break;

      case Token.NAME:
        if (undefinedRight) {
          result = compareToUndefined(left, op);
          break;
        }

        if (rightLiteral) {
          boolean undefinedLeft = (left.getString().equals("undefined"));
          if (undefinedLeft) {
            result = compareToUndefined(right, op);
            break;
          }
        }

        if (Token.NAME != right.getType()) {
          return n;  // Only eval if they are the same type
        }
        String ln = left.getString();
        String rn = right.getString();
        if (!ln.equals(rn)) {
          return n;  // Not the same value name.
        }

        switch (op) {
          // If we knew the named value wouldn't be NaN, it would be nice
          // to handle EQ,NE,LE,GE,SHEQ, and SHNE.
          case Token.LT:
          case Token.GT:
            result = false;
            break;
          default:
            return n;  // don't handle that op
        }
        break;

      default:
        // assert, this should cover all consts
        return n;
    }
19:23:26.789 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:27.752 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:27.753 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:28.710 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
int lhType = right.getType();
int op = right.getType();
19:23:28.712 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:29.685 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:29.685 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
19:23:30.668 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-74 ---Fixer: fix fail because of failed compiling! 
19:23:30.669 [main] INFO edu.lu.uni.serval.bug.fixer.FixMinerFixer - =======Finish off Fixing======
19:23:30.902 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-74/aggregatedSusInfo.profl
Failed to fix bug Closure-74
