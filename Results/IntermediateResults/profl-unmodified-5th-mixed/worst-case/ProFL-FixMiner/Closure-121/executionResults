Setting JAVA_HOME to /mnt/efs/fs1/jdk1.7.0_80

Adding /mnt/efs/fs1/jdk1.7.0_80/bin: to PATH environmental variable

java version "1.7.0_80"
Java(TM) SE Runtime Environment (build 1.7.0_80-b15)
Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode)

Java 7 environment setup completed
Closure-121
03:24:24.606 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 Failed Tests: 1
Reading method line coverage from /mnt/efs/fs1/XiaInformation/AllMethods/Closure/121.txt
Reading test line coverage from /mnt/efs/fs1/XiaInformation/LineCoverage/Closure/121.txt
03:29:22.850 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - ProFL successfully initialized
03:29:22.924 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-121/generalSusInfo.profl
03:29:23.015 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-121/aggregatedSusInfo.profl
03:29:23.018 [main] INFO edu.lu.uni.serval.bug.fixer.FixMinerFixer - =======Fixing Beginning======
03:29:23.018 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Node ===1459
03:29:24.129 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return res;
if (res != null) {


}

03:29:24.147 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:25.166 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (res == null) {
    return null;
}

if (res == null) {
    throw new IllegalArgumentException("Empty variable: " + res);
}

03:29:25.168 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:26.143 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:26.144 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:27.140 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
detachChildren();
	return res;
return res;
	detachChildren();
setQuotedString();
	return res;
return res;
	setQuotedString();
03:29:27.143 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:28.113 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:28.113 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:29.102 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:29.103 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:30.064 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:30.064 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:31.044 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 

03:29:31.046 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:32.009 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:32.009 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Node ===1430
03:29:32.159 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return "Node tree inequality:" +
            "\nTree1:\n" + toStringTree() +
            "\n\nTree2:\n" + node2.toStringTree() +
            "\n\nSubtree1: " + diff.nodeA.toStringTree() +
            "\n\nSubtree2: " + diff.nodeB.toStringTree();
if (node2 != null) {


}

03:29:32.162 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:33.112 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (node2 == null) {
    return null;
}

if (node2 == null) {
    throw new IllegalArgumentException("Empty variable: " + node2);
}

03:29:33.113 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:34.091 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:34.091 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:35.039 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 

03:29:35.041 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:36.016 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:36.016 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Node ===1446
03:29:36.096 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return new NodeMismatch(this, node2);
if (node2 != null) {


}

03:29:36.098 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:37.030 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (node2 == null) {
    return null;
}

if (node2 == null) {
    throw new IllegalArgumentException("Empty variable: " + node2);
}

03:29:37.032 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:38.026 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:38.027 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:38.994 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
addChildToFront(node2);
addChildToFront(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildToFront(node2);
addChildToBack(node2);
addChildToBack(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildToBack(node2);
addChildrenToFront(node2);
addChildrenToFront(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildrenToFront(node2);
addChildrenToBack(node2);
addChildrenToBack(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	addChildrenToBack(node2);
removeChild(node2);
removeChild(node2);
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	removeChild(node2);
detachChildren();
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	detachChildren();
setQuotedString();
	return new NodeMismatch(this, node2);
return new NodeMismatch(this, node2);
	setQuotedString();
03:29:38.996 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:39.953 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:39.953 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:40.932 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:40.932 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:41.864 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:41.864 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:42.817 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:42.818 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:43.781 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:43.782 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:44.757 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:44.758 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:45.715 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:45.716 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:46.684 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:46.685 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:47.693 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:47.694 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:48.718 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:48.719 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:49.677 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:49.677 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:50.670 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:50.671 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:51.632 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:51.633 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:52.584 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:52.585 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:53.525 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:53.526 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:54.514 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:54.514 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:55.507 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:55.508 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:56.444 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:56.445 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:57.429 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 

03:29:57.431 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:58.417 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:58.417 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.Token ===221
03:29:58.426 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case SHEQ:
if (SHEQ == 0) {
    new IllegalArgumentException("");
}

if (SHEQ != 0) {

    
}

if (SHEQ > 0) {

    
}

03:29:58.428 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:59.024 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:59.024 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:59.341 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:29:59.341 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:29:59.646 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 

03:29:59.647 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:00.213 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:00.213 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.NodeUtil ===2185
03:30:00.396 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case Token.SHEQ:

03:30:00.403 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:01.476 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:01.477 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.NodeUtil ===1607
03:30:01.573 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return n.getNext();
return n.getNext(parent);
return n.getNext(MAX_POSITIVE_INTEGER_NUMBER);
return n.getNext(JSC_PROPERTY_NAME_FN);
return n.getNext(LARGEST_BASIC_LATIN);
return n.getNext(CONSTRUCTORS_WITHOUT_SIDE_EFFECTS);
return n.getNext(BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS);
return n.getNext(OBJECT_METHODS_WITHOUT_SIDEEFFECTS);
return n.getNext(REGEXP_METHODS);
return n.getNext(STRING_REGEXP_METHODS);
return n.getNext(IMMUTABLE_PREDICATE);
return n.getNext(NUMBERIC_RESULT_PREDICATE);
return n.getNext(BOOLEAN_RESULT_PREDICATE);
return n.getNext(MAY_BE_STRING_PREDICATE);
return n.getNext(MATCH_NOT_FUNCTION);
03:30:01.576 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:02.681 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:02.682 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:03.776 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:03.777 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:04.844 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:04.845 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:05.926 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:05.927 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:07.000 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:07.001 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:08.073 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:08.073 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:09.175 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:09.176 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:10.279 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:10.280 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:11.357 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:11.358 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:12.431 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:12.432 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:13.557 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:13.558 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:14.631 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:14.631 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:15.703 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:15.704 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:16.833 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
return n.getAncestors();
return n.getJSType();
return n.getType();
return n.getLength();
return n.getLineno();
return n.getCharno();
return n.getSourceOffset();
return n.getSourcePosition();
return n.getChildCount();
return n.getChangeTime();
return n.getSideEffectFlags();
return n.getSortedPropTypes();
return n.getPropListHeadForTesting();
return n.detachChildren();
return n.setQuotedString();
return n.getDouble();
return n.getStaticSourceFile();
return n.getInputId();
return n.children();
return n.siblings();
return n.getJSDocInfo();
return n.getFirstChild();
return n.getLastChild();
return n.getLastSibling();
return n.getParent();
return n.detachFromParent();
return n.removeFirstChild();
return n.removeChildren();
return n.cloneNode();
return n.cloneTree();
return n.getString();
return n.toString();
return n.toStringTree();
return n.toStringTreeImpl();
return n.getSourceFileName();
return n.getQualifiedName();
return n.hasChildren();
return n.isFromExterns();
return n.hasOneChild();
return n.hasMoreThanOneChild();
return n.isQualifiedName();
return n.isUnscopedQualifiedName();
return n.isVarArgs();
return n.isOptionalArg();
return n.isSyntheticBlock();
return n.wasEmptyNode();
return n.isOnlyModifiesThisCall();
return n.isOnlyModifiesArgumentsCall();
return n.isNoSideEffectsCall();
return n.isLocalResultCall();
return n.mayMutateArguments();
return n.mayMutateGlobalStateOrThrow();
return n.isQuotedString();
return n.isAdd();
return n.isAnd();
return n.isArrayLit();
return n.isAssign();
return n.isAssignAdd();
return n.isBlock();
return n.isBreak();
return n.isCall();
return n.isCase();
return n.isCast();
return n.isCatch();
return n.isComma();
return n.isContinue();
return n.isDebugger();
return n.isDec();
return n.isDefaultCase();
return n.isDelProp();
return n.isDo();
return n.isEmpty();
return n.isExprResult();
return n.isFalse();
return n.isFor();
return n.isFunction();
return n.isGetterDef();
return n.isGetElem();
return n.isGetProp();
return n.isHook();
return n.isIf();
return n.isIn();
return n.isInc();
return n.isInstanceOf();
return n.isLabel();
return n.isLabelName();
return n.isName();
return n.isNE();
return n.isNew();
return n.isNot();
return n.isNull();
return n.isNumber();
return n.isObjectLit();
return n.isOr();
return n.isParamList();
return n.isRegExp();
return n.isReturn();
return n.isScript();
return n.isSetterDef();
return n.isString();
return n.isStringKey();
return n.isSwitch();
return n.isThis();
return n.isThrow();
return n.isTrue();
return n.isTry();
return n.isTypeOf();
return n.isVar();
return n.isVoid();
return n.isWhile();
return n.isWith();
return n.getDirectives();
return n.getJsDocBuilderForNode();
03:30:16.883 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:17.975 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:17.976 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:19.070 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:19.071 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:20.172 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:20.173 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:21.285 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:21.286 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:22.353 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:22.354 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:23.440 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:23.441 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:24.499 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:24.500 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:25.569 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:25.569 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:26.678 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:26.679 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:27.777 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:27.777 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:28.895 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:28.896 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:30.002 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:30.002 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:31.102 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:31.102 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:32.199 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:32.200 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:33.280 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:33.281 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:34.365 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:34.366 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:35.470 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:35.471 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:36.537 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:36.538 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:37.597 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:37.597 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:38.662 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:38.663 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:39.763 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:39.764 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:40.833 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:40.834 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:41.895 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:41.896 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:42.961 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:42.961 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:44.030 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:44.031 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:45.065 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:45.066 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:46.179 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:46.180 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:47.244 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:47.245 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:48.357 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:48.357 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:49.430 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:49.431 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:50.556 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:50.557 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:51.649 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:51.650 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:52.733 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:52.734 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:53.795 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:53.795 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:54.871 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:54.872 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:55.940 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:55.940 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:57.017 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:57.017 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:58.103 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:58.104 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:30:59.188 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:30:59.189 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:00.266 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:00.267 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:01.353 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:01.354 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:02.456 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:02.456 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:03.555 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:03.556 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:04.637 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:04.638 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:05.764 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:05.765 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:06.859 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:06.860 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:07.963 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:07.963 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:09.031 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:09.031 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:10.105 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:10.106 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:11.210 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:11.211 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:12.283 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:12.284 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:13.441 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:13.442 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:14.554 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:14.555 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:15.677 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:15.677 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:16.783 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:16.784 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:17.932 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:17.933 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:19.073 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:19.074 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:20.230 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:20.231 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:21.357 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:21.358 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:22.496 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:22.497 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:23.622 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:23.623 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:24.758 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:24.759 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:25.872 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:25.873 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:26.966 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:26.967 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:28.061 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:28.062 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:29.202 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:29.202 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:30.325 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:30.325 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:31.415 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:31.415 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:32.538 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:32.539 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:33.674 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:33.674 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:34.766 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:34.767 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:35.859 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:35.860 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:36.964 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:36.965 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:38.076 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:38.077 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:39.172 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:39.173 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:40.278 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:40.281 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:41.407 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:41.407 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:42.475 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:42.476 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:43.589 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:43.590 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:44.704 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:44.704 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:45.807 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:45.808 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:46.931 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:46.932 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:48.017 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:48.018 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:49.100 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:49.101 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:50.212 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:50.213 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:51.374 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:51.375 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:52.450 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:52.451 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:53.561 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:53.561 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:54.659 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:54.659 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:55.757 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:55.758 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:56.898 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:56.898 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:57.996 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:57.997 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:31:59.120 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:31:59.121 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:00.225 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:00.226 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:01.318 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:01.319 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:02.428 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:02.429 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:03.481 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:03.481 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:04.564 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:04.564 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:05.622 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:05.623 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:06.689 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:06.690 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:07.785 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:07.785 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:08.886 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:08.887 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:10.014 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:10.014 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:11.119 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:11.120 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:12.215 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:12.216 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:13.293 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:13.293 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:14.369 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:14.370 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:15.486 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:15.486 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:16.585 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:16.586 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:17.700 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:17.701 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:18.822 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:18.822 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:19.900 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:19.901 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:21.046 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
return n.getNext(true);
return n.getNext(false);
03:32:21.049 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:22.140 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:22.140 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:23.221 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (n != null) {


}

03:32:23.223 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:24.296 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (n == null) {
    return null;
}

if (n == null) {
    throw new IllegalArgumentException("Empty variable: " + n);
}

03:32:24.297 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:25.393 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:25.394 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:26.479 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 

03:32:26.481 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:27.616 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:27.617 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.parsing.IRFactory ===1397
03:32:27.678 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return Token.SHEQ;

03:32:27.682 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:28.719 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:28.720 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.NodeUtil ===1223
03:32:28.797 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
case Token.SHNE:

03:32:28.801 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:29.915 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:29.916 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.NodeUtil ===1606
03:32:30.008 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
if (parent.isAssign() && parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
if (parent.isAssign() || parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
if (parent.isAssign() && parent.getFirstChild() != n) {
      return n.getNext();
    } else {
      return null;
    }
03:32:30.010 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:31.141 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:31.141 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:32.222 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (parent.isAssign() && parent.getFirstChild() == parent) {
      return n.getNext();
    } else {
      return null;
    }
03:32:32.224 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:33.280 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (parent != null) {


}

if (parent != null) {


}

if (n != null) {


}

03:32:33.282 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:34.381 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:34.381 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:35.538 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:35.539 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:36.604 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (parent == null) {
    return null;
}

if (parent == null) {
    throw new IllegalArgumentException("Empty variable: " + parent);
}

if (parent == null) {
    return null;
}

if (parent == null) {
    throw new IllegalArgumentException("Empty variable: " + parent);
}

if (n == null) {
    return null;
}

if (n == null) {
    throw new IllegalArgumentException("Empty variable: " + n);
}

03:32:36.605 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:37.669 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:37.670 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:38.746 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:38.747 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:39.846 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:39.847 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:40.925 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:40.925 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:42.041 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:42.042 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:43.172 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
maybeAddFinally(n);
maybeAddFinally(n);
	if (parent.isAssign() && parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
if (parent.isAssign() && parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
	maybeAddFinally(n);
redeclareVarsInsideBranch(n);
redeclareVarsInsideBranch(n);
	if (parent.isAssign() && parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
if (parent.isAssign() && parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
	redeclareVarsInsideBranch(n);
03:32:43.177 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:44.299 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:44.300 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:45.400 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:45.401 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:46.511 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:46.512 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:47.640 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:47.641 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:48.763 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:48.765 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:49.857 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
if (parent.isAssign() && parent.getFirstChild() == n) {
      return n.getNext();
    } else {
      return null;
    }
	return n.getFirstChild();
    } else 
null
03:32:49.859 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:50.215 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 

03:32:50.217 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:50.588 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:50.588 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.InlineVariables ===92
03:32:50.667 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return Predicates.<Var>alwaysTrue();
return Predicates.<Var>alwaysTrue(this.compiler);
return Predicates.<Var>alwaysTrue(this.mode);
return Predicates.<Var>alwaysTrue(this.inlineAllStrings);
return Predicates.<Var>alwaysTrue(this.identifyConstants);
03:32:50.668 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:51.536 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:51.536 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:52.439 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:52.439 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:53.316 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:53.317 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:54.172 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
return getFilterForMode().<Var>alwaysTrue();
03:32:54.173 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:55.010 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
return Predicates.<Var>alwaysTrue(true);
return Predicates.<Var>alwaysTrue(false);
03:32:55.011 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:55.868 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:55.868 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:56.744 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 

03:32:56.746 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
03:32:57.577 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-121 ---Fixer: fix fail because of failed compiling! 
03:32:57.577 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.InlineVariables ===54
03:32:57.634 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
InlineVariables implements CompilerPass {

  private final AbstractCompiler compiler;

  enum Mode {
    // Only inline things explicitly marked as constant.
    CONSTANTS_ONLY,
    // Locals only
    LOCALS_ONLY,
    ALL
  }

  private final Mode mode;

  // Inlines all strings, even if they increase the size of the gzipped binary.
  private final boolean inlineAllStrings;

  private final IdentifyConstants identifyConstants = new IdentifyConstants();

  InlineVariables(
      AbstractCompiler compiler,
      Mode mode,
      boolean inlineAllStrings) {
    this.compiler = compiler;
    this.mode = mode;
    this.inlineAllStrings = inlineAllStrings;
  }

  @Override
  public void process(Node externs, Node root) {
    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(
        compiler, new InliningBehavior(), getFilterForMode());
    callback.process(externs, root);
  }

  private Predicate<Var> getFilterForMode() {
    switch (mode) {
      case ALL:
        return Predicates.<Var>alwaysTrue();
      case LOCALS_ONLY:
        return new IdentifyLocals();
      case CONSTANTS_ONLY:
        return new IdentifyConstants();
      default:
        throw new IllegalStateException();
    }
  }

  /**
   * Filters variables declared as "constant", and declares them in the outer
   * declaredConstants map.
   *
   * In Google coding conventions, this means anything declared with @const
   * or named in all caps, and initialized to an immutable value.
   * CheckConsts has already verified that these are truly constants.
   */
  private class IdentifyConstants implements Predicate<Var> {
    @Override
    public boolean apply(Var var) {
      return var.isConst();
    }
  }

  /**
   * Filters non-global variables.
   */
  private class IdentifyLocals implements Predicate<Var> {
    @Override
    public boolean apply(Var var) {
      return var.scope.isLocal();
    }
  }

  private static class AliasCandidate {
    private final Var alias;
    private final ReferenceCollection refInfo;

    AliasCandidate(Var alias, ReferenceCollection refInfo) {
      this.alias = alias;
      this.refInfo = refInfo;
    }
  }

  /**
   * Builds up information about nodes in each scope. When exiting the
   * scope, inspects all variables in that scope, and inlines any
   * that we can.
   */
  private class InliningBehavior implements Behavior {

    /**
     * A list of variables that should not be inlined, because their
     * reference information is out of sync with the state of the AST.
     */
    private final Set<Var> staleVars = Sets.newHashSet();

    /**
     * Stored possible aliases of variables that never change, with
     * all the reference info about those variables. Hashed by the NAME
     * node of the variable being aliased.
     */
    final Map<Node, AliasCandidate> aliasCandidates = Maps.newHashMap();

    @Override
    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {
      collectAliasCandidates(t, referenceMap);
      doInlinesForScope(t, referenceMap);
    }

    /**
     * If any of the variables are well-defined and alias other variables,
     * mark them as aliasing candidates.
     */
    private void collectAliasCandidates(NodeTraversal t,
        ReferenceMap referenceMap) {
      if (mode != Mode.CONSTANTS_ONLY) {
        for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
          Var v = it.next();
          ReferenceCollection referenceInfo = referenceMap.getReferences(v);

          // NOTE(nicksantos): Don't handle variables that are never used.
          // The tests are much easier to write if you don't, and there's
          // another pass that handles unused variables much more elegantly.
          if (referenceInfo != null && referenceInfo.references.size() >= 2 &&
              referenceInfo.isWellDefined() &&
              referenceInfo.isAssignedOnceInLifetime()) {
            Reference init = referenceInfo.getInitializingReference();
            Node value = init.getAssignedValue();
            if (value != null && value.isName()) {
              aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));
            }
          }
        }
      }
    }

    /**
     * For all variables in this scope, see if they are only used once.
     * If it looks safe to do so, inline them.
     */
    private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) {

      boolean maybeModifiedArguments =
          maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);
      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {
        Var v = it.next();

        ReferenceCollection referenceInfo = referenceMap.getReferences(v);

        // referenceInfo will be null if we're in constants-only mode
        // and the variable is not a constant.
        if (referenceInfo == null || isVarInlineForbidden(v)) {
          // Never try to inline exported variables or variables that
          // were not collected or variables that have already been inlined.
          continue;
        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {
          Reference init = referenceInfo.getInitializingReferenceForConstants();
          Node value = init.getAssignedValue();
          inlineDeclaredConstant(v, value, referenceInfo.references);
          staleVars.add(v);
        } else if (mode == Mode.CONSTANTS_ONLY) {
          // If we're in constants-only mode, don't run more aggressive
          // inlining heuristics. See InlineConstantsTest.
          continue;
        } else {
          inlineNonConstants(v, referenceInfo, maybeModifiedArguments);
        }
      }
    }

    private boolean maybeEscapedOrModifiedArguments(
        Scope scope, ReferenceMap referenceMap) {
      if (scope.isLocal()) {
        Var arguments = scope.getArgumentsVar();
        ReferenceCollection refs = referenceMap.getReferences(arguments);
        if (refs != null && !refs.references.isEmpty()) {
          for (Reference ref : refs.references) {
            Node refNode = ref.getNode();
            Node refParent = ref.getParent();
            // Any reference that is not a read of the arguments property
            // consider a escape of the arguments object.
            if (!(NodeUtil.isGet(refParent)
                && refNode == ref.getParent().getFirstChild()
                && !isLValue(refParent))) {
              return true;
            }
          }
        }
      }
      return false;
    }

    private boolean isLValue(Node n) {
      Node parent = n.getParent();
      return (parent.isInc()
          || parent.isDec()
          || (NodeUtil.isAssignmentOp(parent)
          && parent.getFirstChild() == n));
    }

    private void inlineNonConstants(
        Var v, ReferenceCollection referenceInfo,
        boolean maybeModifiedArguments) {
      int refCount = referenceInfo.references.size();
      Reference declaration = referenceInfo.references.get(0);
      Reference init = referenceInfo.getInitializingReference();
      int firstRefAfterInit = (declaration == init) ? 2 : 3;

      if (refCount > 1 &&
          isImmutableAndWellDefinedVariable(v, referenceInfo)) {
        // if the variable is referenced more than once, we can only
        // inline it if it's immutable and never defined before referenced.
        Node value;
        if (init != null) {
          value = init.getAssignedValue();
        } else {
          // Create a new node for variable that is never initialized.
          Node srcLocation = declaration.getNode();
          value = NodeUtil.newUndefinedNode(srcLocation);
        }
        Preconditions.checkNotNull(value);
        inlineWellDefinedVariable(v, value, referenceInfo.references);
        staleVars.add(v);
      } else if (refCount == firstRefAfterInit) {
        // The variable likely only read once, try some more
        // complex inlining heuristics.
        Reference reference = referenceInfo.references.get(
            firstRefAfterInit - 1);
        if (canInline(declaration, init, reference)) {
          inline(v, declaration, init, reference);
          staleVars.add(v);
        }
      } else if (declaration != init && refCount == 2) {
        if (isValidDeclaration(declaration) && isValidInitialization(init)) {
          // The only reference is the initialization, remove the assignment and
          // the variable declaration.
          Node value = init.getAssignedValue();
          Preconditions.checkNotNull(value);
          inlineWellDefinedVariable(v, value, referenceInfo.references);
          staleVars.add(v);
        }
      }

      // If this variable was not inlined normally, check if we can
      // inline an alias of it. (If the variable was inlined, then the
      // reference data is out of sync. We're better off just waiting for
      // the next pass.)
      if (!maybeModifiedArguments &&
          !staleVars.contains(v) &&
          referenceInfo.isWellDefined() &&
          referenceInfo.isAssignedOnceInLifetime()) {
          // Inlining the variable based solely on well-defined and assigned
          // once is *NOT* correct. We relax the correctness requirement if
          // the variable is declared constant.
        List<Reference> refs = referenceInfo.references;
        for (int i = 1 /* start from a read */; i < refs.size(); i++) {
          Node nameNode = refs.get(i).getNode();
          if (aliasCandidates.containsKey(nameNode)) {
            AliasCandidate candidate = aliasCandidates.get(nameNode);
            if (!staleVars.contains(candidate.alias) &&
                !isVarInlineForbidden(candidate.alias)) {
              Reference aliasInit;
              aliasInit = candidate.refInfo.getInitializingReference();
              Node value = aliasInit.getAssignedValue();
              Preconditions.checkNotNull(value);
              inlineWellDefinedVariable(candidate.alias,
                  value,
                  candidate.refInfo.references);
              staleVars.add(candidate.alias);
            }
          }
        }
      }
    }

    /**
     * If there are any variable references in the given node tree, blacklist
     * them to prevent the pass from trying to inline the variable.
     */
    private void blacklistVarReferencesInTree(Node root, Scope scope) {
      for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {
        blacklistVarReferencesInTree(c, scope);
      }

      if (root.isName()) {
        staleVars.add(scope.getVar(root.getString()));
      }
    }

    /**
     * Whether the given variable is forbidden from being inlined.
     */
    private boolean isVarInlineForbidden(Var var) {
      // A variable may not be inlined if:
      // 1) The variable is exported,
      // 2) A reference to the variable has been inlined. We're downstream
      //    of the mechanism that creates variable references, so we don't
      //    have a good way to update the reference. Just punt on it.
      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME
      return var.isExtern()
          || compiler.getCodingConvention().isExported(var.name)
          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)
          || staleVars.contains(var);
    }

    /**
     * Do the actual work of inlining a single declaration into a single
     * reference.
     */
    private void inline(Var v, Reference decl, Reference init, Reference ref) {
      Node value = init.getAssignedValue();
      Preconditions.checkState(value != null);
      // Check for function declarations before the value is moved in the AST.
      boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(value);
      compiler.reportChangeToEnclosingScope(ref.getNode());
      inlineValue(v, ref, value.detachFromParent());
      if (decl != init) {
        Node expressRoot = init.getGrandparent();
        Preconditions.checkState(expressRoot.isExprResult());
        NodeUtil.removeChild(expressRoot.getParent(), expressRoot);
      }
      // Function declarations have already been removed.
      if (!isFunctionDeclaration) {
        compiler.reportChangeToEnclosingScope(decl.getNode());
        removeDeclaration(decl);
      }
    }

    /**
     * Inline an immutable variable into all of its references.
     */
    private void inlineWellDefinedVariable(Var v, Node value,
        List<Reference> refSet) {
      Reference decl = refSet.get(0);
      for (int i = 1; i < refSet.size(); i++) {
        inlineValue(v, refSet.get(i), value.cloneTree());
      }
      removeDeclaration(decl);
    }

    /**
     * Inline a declared constant.
     */
    private void inlineDeclaredConstant(Var v, Node value,
        List<Reference> refSet) {
      // Replace the references with the constant value
      Reference decl = null;

      for (Reference r : refSet) {
        if (r.getNode() == v.getNameNode()) {
          decl = r;
        } else {
          inlineValue(v, r, value.cloneTree());
        }
      }

      removeDeclaration(decl);
    }

    /**
     * Remove the given VAR declaration.
     */
    private void removeDeclaration(Reference decl) {
      Node varNode = decl.getParent();
      Node grandparent = decl.getGrandparent();

      compiler.reportChangeToEnclosingScope(decl.getNode());
      varNode.removeChild(decl.getNode());
      // Remove var node if empty
      if (!varNode.hasChildren()) {
        Preconditions.checkState(varNode.isVar());
        NodeUtil.removeChild(grandparent, varNode);
      }
    }

    /**
     * Replace the given reference with the given value node.
     *
     * @param v The variable that's referenced.
     * @param ref The reference to replace.
     * @param value The node tree to replace it with. This tree should be safe
     *     to re-parent.
     */
    private void inlineValue(Var v, Reference ref, Node value) {
      compiler.reportChangeToEnclosingScope(ref.getNode());
      if (ref.isSimpleAssignmentToName()) {
        // This is the initial assignment.
        ref.getGrandparent().replaceChild(ref.getParent(), value);
      } else {
        ref.getParent().replaceChild(ref.getNode(), value);
      }
      blacklistVarReferencesInTree(value, v.scope);
    }

    /**
     * Determines whether the given variable is declared as a constant
     * and may be inlined.
     */
    private boolean isInlineableDeclaredConstant(Var var,
        ReferenceCollection refInfo) {
      if (!identifyConstants.apply(var)) {
        return false;
      }

      if (!refInfo.isAssignedOnceInLifetime()) {
        return false;
      }

      Reference init = refInfo.getInitializingReferenceForConstants();
      if (init == null) {
        return false;
      }

      Node value = init.getAssignedValue();
      if (value == null) {
        // This constant is either externally defined or initialized indirectly
        // (e.g. in an function expression used to hide
        // temporary variables), so the constant is ineligible for inlining.
        return false;
      }

      // Is the constant's value immutable?
      if (!NodeUtil.isImmutableValue(value)) {
        return false;
      }

      // Determine if we should really inline a String or not.
      return !value.isString() ||
          isStringWorthInlining(var, refInfo.references);
    }

    /**
     * Compute whether the given string is worth inlining.
     */
    private boolean isStringWorthInlining(Var var, List<Reference> refs) {
      if (!inlineAllStrings && !var.isDefine()) {
        int len = var.getInitialValue().getString().length() + "''".length();

        // if not inlined: var xx="value"; .. xx .. xx ..
        // The 4 bytes per reference is just a heuristic:
        // 2 bytes per var name plus maybe 2 bytes if we don't inline, e.g.
        // in the case of "foo " + CONST + " bar"
        int noInlineBytes = "var xx=;".length() + len +
                            4 * (refs.size() - 1);

        // if inlined:
        // I'm going to assume that half of the quotes will be eliminated
        // thanks to constant folding, therefore I subtract 1 (2/2=1) from
        // the string length.
        int inlineBytes = (len - 1) * (refs.size() - 1);

        // Not inlining if doing so uses more bytes, or this constant is being
        // defined.
        return noInlineBytes >= inlineBytes;
      }

      return true;
    }

    /**
     * @return true if the provided reference and declaration can be safely
     *         inlined according to our criteria
     */
    private boolean canInline(
        Reference declaration,
        Reference initialization,
        Reference reference) {
      if (!isValidDeclaration(declaration)
          || !isValidInitialization(initialization)
          || !isValidReference(reference)) {
        return false;
      }

      // If the value is read more than once, skip it.
      // VAR declarations and EXPR_RESULT don't need the value, but other
      // ASSIGN expressions parents do.
      if (declaration != initialization &&
          !initialization.getGrandparent().isExprResult()) {
        return false;
      }

      // Be very conservative and do no cross control structures or
      // scope boundaries
      if (declaration.getBasicBlock() != initialization.getBasicBlock()
          || declaration.getBasicBlock() != reference.getBasicBlock()) {
        return false;
      }

      // Do not inline into a call node. This would change
      // the context in which it was being called. For example,
      //   var a = b.c;
      //   a();
      // should not be inlined, because it calls a in the context of b
      // rather than the context of the window.
      //   var a = b.c;
      //   f(a)
      // is OK.
      Node value = initialization.getAssignedValue();
      Preconditions.checkState(value != null);
      if (value.isGetProp()
          && reference.getParent().isCall()
          && reference.getParent().getFirstChild() == reference.getNode()) {
        return false;
      }

      if (value.isFunction()) {
        Node callNode = reference.getParent();
        if (reference.getParent().isCall()) {
          CodingConvention convention = compiler.getCodingConvention();
          // Bug 2388531: Don't inline subclass definitions into class defining
          // calls as this confused class removing logic.
          SubclassRelationship relationship =
              convention.getClassesDefinedByCall(callNode);
          if (relationship != null) {
            return false;
          }

          // issue 668: Don't inline singleton getter methods
          // calls as this confused class removing logic.
          if (convention.getSingletonGetterClassName(callNode) != null) {
            return false;
          }
        }
      }

      return canMoveAggressively(value) ||
          canMoveModerately(initialization, reference);
    }

    /**
     * If the value is a literal, we can cross more boundaries to inline it.
     */
    private boolean canMoveAggressively(Node value) {
      // Function expressions and other mutable objects can move within
      // the same basic block.
      return NodeUtil.isLiteralValue(value, true)
          || value.isFunction();
    }

    /**
     * If the value of a variable is not constant, then it may read or modify
     * state. Therefore it cannot be moved past anything else that may modify
     * the value being read or read values that are modified.
     */
    private boolean canMoveModerately(
        Reference initialization,
        Reference reference) {
      // Check if declaration can be inlined without passing
      // any side-effect causing nodes.
      Iterator<Node> it;
      if (initialization.getParent().isVar()) {
        it = NodeIterators.LocalVarMotion.forVar(
            initialization.getNode(),     // NAME
            initialization.getParent(),       // VAR
            initialization.getGrandparent()); // VAR container
      } else if (initialization.getParent().isAssign()) {
        Preconditions.checkState(
            initialization.getGrandparent().isExprResult());
        it = NodeIterators.LocalVarMotion.forAssign(
            initialization.getNode(),     // NAME
            initialization.getParent(),       // ASSIGN
            initialization.getGrandparent(),  // EXPR_RESULT
            initialization.getGrandparent().getParent()); // EXPR container
      } else {
        throw new IllegalStateException("Unexpected initialization parent " +
            initialization.getParent().toStringTree());
      }
      Node targetName = reference.getNode();
      while (it.hasNext()) {
        Node curNode = it.next();
        if (curNode == targetName) {
          return true;
        }
      }

      return false;
    }

    /**
     * @return true if the reference is a normal VAR or FUNCTION declaration.
     */
    private boolean isValidDeclaration(Reference declaration) {
      return (declaration.getParent().isVar()
          && !declaration.getGrandparent().isFor())
          || NodeUtil.isFunctionDeclaration(declaration.getParent());
    }

    /**
     * @return Whether there is a initial value.
     */
    private boolean isValidInitialization(Reference initialization) {
      if (initialization == null) {
        return false;
      } else if (initialization.isDeclaration()) {
        // The reference is a FUNCTION declaration or normal VAR declaration
        // with a value.
        if (!NodeUtil.isFunctionDeclaration(initialization.getParent())
            && initialization.getNode().getFirstChild() == null) {
          return false;
        }
      } else {
        Node parent = initialization.getParent();
        Preconditions.checkState(
            parent.isAssign()
            && parent.getFirstChild() == initialization.getNode());
      }

      Node n = initialization.getAssignedValue();
      if (n.isFunction()) {
        return compiler.getCodingConvention().isInlinableFunction(n);
      }

      return true;
    }

    /**
     * @return true if the reference is a candidate for inlining
     */
    private boolean isValidReference(Reference reference) {
      return !reference.isDeclaration() && !reference.isLvalue();
    }

    /**
     * Determines whether the reference collection describes a variable that
     * is initialized to an immutable value, never modified, and defined before
     * every reference.
     */
    private boolean isImmutableAndWellDefinedVariable(Var v,
        ReferenceCollection refInfo) {
      List<Reference> refSet = refInfo.references;
      int startingReadRef = 1;
      Reference refDecl = refSet.get(0);
      if (!isValidDeclaration(refDecl)) {
        return false;
      }

      boolean isNeverAssigned = refInfo.isNeverAssigned();
      // For values that are never assigned, only the references need to be
      // checked.
      if (!isNeverAssigned) {
        Reference refInit = refInfo.getInitializingReference();
        if (!isValidInitialization(refInit)) {
          return false;
        }

        if (refDecl != refInit) {
          Preconditions.checkState(refInit == refSet.get(1));
          startingReadRef = 2;
        }

        if (!refInfo.isWellDefined()) {
          return false;
        }

        Node value = refInit.getAssignedValue();
        Preconditions.checkNotNull(value);

        boolean isImmutableValueWorthInlining =
            NodeUtil.isImmutableValue(value) &&
            (!value.isString() ||
                isStringWorthInlining(v, refInfo.references));
        boolean isInlinableThisAlias =
            value.isThis() &&
            !refInfo.isEscaped();
        if (!isImmutableValueWorthInlining && !isInlinableThisAlias) {
          return false;
        }
      }

      for (int i = startingReadRef; i < refSet.size(); i++) {
        Reference ref = refSet.get(i);
        if (!isValidReference(ref)) {
          return false;
        }
      }

      return true;
    }
  }
}
Exception in thread "main" java.lang.NullPointerException
	at edu.lu.uni.serval.fixminer.insertTemplate.InsertIfNullCheck.readReturnType(InsertIfNullCheck.java:69)
	at edu.lu.uni.serval.fixminer.insertTemplate.InsertIfNullCheck.generatePatches(InsertIfNullCheck.java:32)
	at edu.lu.uni.serval.bug.fixer.FixMinerFixer.generatePatches(FixMinerFixer.java:266)
	at edu.lu.uni.serval.bug.fixer.FixMinerFixer.fixWithMatchedFixTemplates(FixMinerFixer.java:229)
	at edu.lu.uni.serval.bug.fixer.FixMinerFixer.fixProcess(FixMinerFixer.java:87)
	at edu.lu.uni.serval.fixminer.main.Main.fixBug(Main.java:56)
	at edu.lu.uni.serval.fixminer.main.Main.main(Main.java:21)
