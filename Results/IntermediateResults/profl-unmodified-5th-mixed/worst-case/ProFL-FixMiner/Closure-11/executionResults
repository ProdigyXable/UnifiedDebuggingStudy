Setting JAVA_HOME to /mnt/efs/fs1/jdk1.7.0_80

Adding /mnt/efs/fs1/jdk1.7.0_80/bin: to PATH environmental variable


Java 7 environment setup completed
Closure-11
07:20:54.192 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 Failed Tests: 2
Reading method line coverage from /mnt/efs/fs1/XiaInformation/AllMethods/Closure/11.txt
Reading test line coverage from /mnt/efs/fs1/XiaInformation/LineCoverage/Closure/11.txt
07:24:24.379 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - ProFL successfully initialized
07:24:24.466 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-11/generalSusInfo.profl
07:24:24.577 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Profl information saved to /home/ubuntu/repair-tool/fixminer/ProFL-FixMiner/Closure-11/aggregatedSusInfo.profl
07:24:24.579 [main] INFO edu.lu.uni.serval.bug.fixer.FixMinerFixer - =======Fixing Beginning======
07:24:24.579 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.NoObjectType ===171
07:24:25.187 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return false;
return true;
07:24:25.197 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:25.876 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:24:25.878 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:26.507 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:26.508 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.NoObjectType ===151
07:24:26.549 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return true;
return false;
07:24:26.550 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:27.227 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:24:27.228 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:27.879 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:27.880 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.NoObjectType ===161
07:24:27.912 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return null;

07:24:27.914 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:28.573 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:28.574 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.NoObjectType ===138
07:24:28.604 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return getNativeType(JSTypeNative.NO_TYPE);
return getNativeType(propertyName, JSTypeNative.NO_TYPE);
return getNativeType(JSTypeNative.NO_TYPE, propertyName);
07:24:28.606 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:29.268 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:29.268 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:29.915 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
return toMaybeTemplateType(JSTypeNative.NO_TYPE);
return visit(JSTypeNative.NO_TYPE);
return getTypesUnderEquality(JSTypeNative.NO_TYPE);
return getTypesUnderInequality(JSTypeNative.NO_TYPE);
return getTypesUnderShallowEquality(JSTypeNative.NO_TYPE);
return getTypesUnderShallowInequality(JSTypeNative.NO_TYPE);
return toStringHelper(JSTypeNative.NO_TYPE);
return findPropertyType(JSTypeNative.NO_TYPE);
return getLeastSupertype(JSTypeNative.NO_TYPE);
return getGreatestSubtype(JSTypeNative.NO_TYPE);
return filterNoResolvedType(JSTypeNative.NO_TYPE);
return getRestrictedTypeGivenToBooleanOutcome(JSTypeNative.NO_TYPE);
return testForEquality(JSTypeNative.NO_TYPE);
return setResolvedTypeInternal(JSTypeNative.NO_TYPE);
return matchConstraint(JSTypeNative.NO_TYPE);
return isEquivalentTo(JSTypeNative.NO_TYPE);
return equals(JSTypeNative.NO_TYPE);
return canAssignTo(JSTypeNative.NO_TYPE);
return canTestForEqualityWith(JSTypeNative.NO_TYPE);
return canTestForShallowEqualityWith(JSTypeNative.NO_TYPE);
return isSubtype(JSTypeNative.NO_TYPE);
return differsFrom(JSTypeNative.NO_TYPE);
return setValidator(JSTypeNative.NO_TYPE);
return toMaybeFunctionType(JSTypeNative.NO_TYPE);
return toMaybeParameterizedType(JSTypeNative.NO_TYPE);
07:24:30.297 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:30.957 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:30.957 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:31.632 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:31.632 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:32.312 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:32.314 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:33.017 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:33.017 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:33.678 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:33.678 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:34.329 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:34.330 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:35.048 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:35.048 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:35.718 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:35.718 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:36.375 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:36.375 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:37.024 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:37.024 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:37.685 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:37.685 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:38.393 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:38.393 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:39.092 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:39.092 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:39.774 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:39.774 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:40.432 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:40.433 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:41.082 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:41.082 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:41.758 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:41.758 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:42.426 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:42.426 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:43.077 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:43.077 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:43.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:43.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:44.397 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:44.398 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:45.063 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:45.064 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:45.768 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:45.769 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:46.475 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:46.475 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:47.118 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
return toMaybeFunctionType();
return isNoObjectType();
return getImplicitPrototype();
return getReferenceName();
return matchesNumberContext();
return matchesObjectContext();
return matchesStringContext();
return hashCode();
return getPropertiesCount();
return getConstructor();
07:24:47.120 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:47.792 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:47.793 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:48.435 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:48.436 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:49.125 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:49.125 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:49.784 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:49.785 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:50.440 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:50.441 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:51.105 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:51.105 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:51.768 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:51.768 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:52.422 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:52.422 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:53.089 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:53.089 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:53.790 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
return getNativeType(true, JSTypeNative.NO_TYPE);
return getNativeType(false, JSTypeNative.NO_TYPE);
return getNativeType(JSTypeNative.NO_TYPE, true);
return getNativeType(JSTypeNative.NO_TYPE, false);
07:24:53.791 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:54.499 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:54.500 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:55.152 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:55.153 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:55.807 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:55.807 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:56.471 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:24:56.471 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:57.115 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:57.115 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.JSType ===580
07:24:57.195 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return null;

07:24:57.197 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:57.970 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:57.970 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.NoObjectType ===144
07:24:57.981 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return true;
return false;
07:24:57.982 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:58.648 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:24:58.649 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:24:59.290 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:24:59.290 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.JSType ===576
07:24:59.329 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
if (autoboxObjType != null) {
      return autoboxObjType.findPropertyType(propertyName);
    }
if (autoboxObjType == null) {
      return autoboxObjType.findPropertyType(propertyName);
    }
07:24:59.330 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:00.129 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (autoboxObjType != null) {


}

07:25:00.130 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:00.889 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (autoboxObjType == null) {
    return null;
}

if (autoboxObjType == null) {
    throw new IllegalArgumentException("Empty variable: " + autoboxObjType);
}

07:25:00.890 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:01.638 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:01.639 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:02.393 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
clearResolved();
	if (autoboxObjType != null) {
      return autoboxObjType.findPropertyType(propertyName);
    }
if (autoboxObjType != null) {
      return autoboxObjType.findPropertyType(propertyName);
    }
	clearResolved();
07:25:02.395 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:03.134 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:03.135 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:03.873 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (autoboxObjType != null) {
      return autoboxObjType.findPropertyType(propertyName);
    }
	ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());
    
null


    return null;
	if (autoboxObjType != null) {
      return autoboxObjType.findPropertyType(propertyName);
    }

MOVE-BUGGY-STATEMENT
07:25:03.874 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:04.610 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:04.610 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:05.341 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:25:05.342 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:06.130 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:06.130 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.JSType ===575
07:25:06.167 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());
ObjectType autoboxObjType = ObjectType.visit(autoboxesTo());
ObjectType autoboxObjType = ObjectType.getOwnPropertyJSDocInfo(autoboxesTo());
ObjectType autoboxObjType = ObjectType.getPropertyNode(autoboxesTo());
ObjectType autoboxObjType = ObjectType.findPropertyType(autoboxesTo());
ObjectType autoboxObjType = ObjectType.getPropertyType(autoboxesTo());
ObjectType autoboxObjType = ObjectType.createDelegateSuffix(autoboxesTo());
ObjectType autoboxObjType = ObjectType.testForEquality(autoboxesTo());
ObjectType autoboxObjType = ObjectType.setJSDocInfo(autoboxesTo());
ObjectType autoboxObjType = ObjectType.collectPropertyNames(autoboxesTo());
ObjectType autoboxObjType = ObjectType.setOwnerFunction(autoboxesTo());
ObjectType autoboxObjType = ObjectType.removeProperty(autoboxesTo());
ObjectType autoboxObjType = ObjectType.hasProperty(autoboxesTo());
ObjectType autoboxObjType = ObjectType.hasOwnProperty(autoboxesTo());
ObjectType autoboxObjType = ObjectType.isPropertyTypeInferred(autoboxesTo());
ObjectType autoboxObjType = ObjectType.isPropertyTypeDeclared(autoboxesTo());
ObjectType autoboxObjType = ObjectType.hasOwnDeclaredProperty(autoboxesTo());
ObjectType autoboxObjType = ObjectType.isPropertyInExterns(autoboxesTo());
ObjectType autoboxObjType = ObjectType.isImplicitPrototype(autoboxesTo());
ObjectType autoboxObjType = ObjectType.getSlot(autoboxesTo());
ObjectType autoboxObjType = ObjectType.getOwnSlot(autoboxesTo());
07:25:06.180 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:06.966 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:06.967 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:07.718 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:07.719 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:08.458 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:08.459 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:09.209 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:09.209 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:09.977 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:09.977 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:10.728 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:10.728 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:11.477 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:11.477 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:12.238 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:12.238 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:12.997 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:12.997 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:13.761 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:13.762 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:14.518 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:14.519 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:15.278 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:15.279 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:16.046 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:16.047 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:16.840 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:16.841 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:17.597 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:17.597 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:18.404 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:18.404 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:19.205 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:19.206 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:19.958 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:19.959 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:20.720 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:20.721 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:21.488 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
ObjectType autoboxObjType = ObjectType.cast(autoboxObjType, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(propertyName, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(this.resolved, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(this.resolveResult, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(this.inTemplatedCheckVisit, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(UNKNOWN_NAME, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(NOT_A_CLASS, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(NOT_A_TYPE, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(EMPTY_TYPE_COMPONENT, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(ALPHA, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(ENUMDECL, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(NOT_ENUMDECL, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(this.registry, autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), autoboxObjType);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), propertyName);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), this.resolved);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), this.resolveResult);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), this.inTemplatedCheckVisit);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), UNKNOWN_NAME);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), NOT_A_CLASS);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), NOT_A_TYPE);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), EMPTY_TYPE_COMPONENT);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), ALPHA);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), ENUMDECL);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), NOT_ENUMDECL);
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo(), this.registry);
07:25:21.490 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:22.278 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:22.279 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:23.063 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:23.063 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:23.828 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:23.828 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:24.592 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:24.592 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:25.366 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:25.367 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:26.124 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:26.124 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:26.940 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:26.940 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:27.704 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:27.705 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:28.475 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:28.475 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:29.223 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:29.224 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:29.974 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:29.975 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:30.780 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:30.781 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:31.553 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:31.553 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:32.323 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:32.324 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:33.113 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:33.113 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:33.883 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:33.883 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:34.643 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:34.643 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:35.413 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:35.413 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:36.181 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:36.182 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:36.955 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:36.956 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:37.731 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:37.731 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:38.501 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:38.501 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:39.322 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:39.323 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:40.122 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:40.123 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:40.901 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:40.902 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:41.671 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
ObjectType autoboxObjType = autoboxObjType.cast(autoboxesTo());
ObjectType autoboxObjType = propertyName.cast(autoboxesTo());
ObjectType autoboxObjType = this.resolved.cast(autoboxesTo());
ObjectType autoboxObjType = this.resolveResult.cast(autoboxesTo());
ObjectType autoboxObjType = this.inTemplatedCheckVisit.cast(autoboxesTo());
ObjectType autoboxObjType = UNKNOWN_NAME.cast(autoboxesTo());
ObjectType autoboxObjType = NOT_A_CLASS.cast(autoboxesTo());
ObjectType autoboxObjType = NOT_A_TYPE.cast(autoboxesTo());
ObjectType autoboxObjType = EMPTY_TYPE_COMPONENT.cast(autoboxesTo());
ObjectType autoboxObjType = ALPHA.cast(autoboxesTo());
ObjectType autoboxObjType = ENUMDECL.cast(autoboxesTo());
ObjectType autoboxObjType = NOT_ENUMDECL.cast(autoboxesTo());
ObjectType autoboxObjType = this.registry.cast(autoboxesTo());
07:25:41.673 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:42.464 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:42.464 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:43.216 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:43.217 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:43.973 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:43.973 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:44.751 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:44.752 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:45.510 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:45.511 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:46.261 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:46.262 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:47.009 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:47.009 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:47.766 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:47.766 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:48.589 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:48.589 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:49.347 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:49.348 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:50.103 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:50.104 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:50.861 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:50.861 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:51.615 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
clearResolved();
	ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());
ObjectType autoboxObjType = ObjectType.cast(autoboxesTo());
	clearResolved();
07:25:51.617 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:52.363 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:52.364 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:53.116 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:25:53.117 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:53.870 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:53.870 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.TypeInference ===550
07:25:53.964 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
registry.registerPropertyOnType(propName, objectType);
registry.registerPropertyOnType(true, propName, objectType);
registry.registerPropertyOnType(false, propName, objectType);
registry.registerPropertyOnType(propName, true, objectType);
registry.registerPropertyOnType(propName, false, objectType);
registry.registerPropertyOnType(propName, objectType, true);
registry.registerPropertyOnType(propName, objectType, false);
07:25:53.967 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:54.910 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:54.910 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:55.830 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:55.831 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:56.745 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:56.746 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:57.659 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:57.660 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:58.628 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:25:58.628 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:25:59.546 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
registry.registerPropertyOnType(nodeType, objectType);
registry.registerPropertyOnType(getprop, objectType);
registry.registerPropertyOnType(rightType, objectType);
registry.registerPropertyOnType(FUNCTION_LITERAL_UNDEFINED_THIS, objectType);
registry.registerPropertyOnType(this.compiler, objectType);
registry.registerPropertyOnType(this.reverseInterpreter, objectType);
registry.registerPropertyOnType(this.syntacticScope, objectType);
registry.registerPropertyOnType(this.functionScope, objectType);
registry.registerPropertyOnType(this.bottomScope, objectType);
registry.registerPropertyOnType(this.assertionFunctionsMap, objectType);
registry.registerPropertyOnType( objectType);
registry.registerPropertyOnType(nodeType, propName, objectType);
registry.registerPropertyOnType(getprop, propName, objectType);
registry.registerPropertyOnType(rightType, propName, objectType);
registry.registerPropertyOnType(FUNCTION_LITERAL_UNDEFINED_THIS, propName, objectType);
registry.registerPropertyOnType(this.compiler, propName, objectType);
registry.registerPropertyOnType(this.reverseInterpreter, propName, objectType);
registry.registerPropertyOnType(this.syntacticScope, propName, objectType);
registry.registerPropertyOnType(this.functionScope, propName, objectType);
registry.registerPropertyOnType(this.bottomScope, propName, objectType);
registry.registerPropertyOnType(this.assertionFunctionsMap, propName, objectType);
registry.registerPropertyOnType(propName, nodeType);
registry.registerPropertyOnType(propName, getprop);
registry.registerPropertyOnType(propName, rightType);
registry.registerPropertyOnType(propName, FUNCTION_LITERAL_UNDEFINED_THIS);
registry.registerPropertyOnType(propName, this.compiler);
registry.registerPropertyOnType(propName, this.reverseInterpreter);
registry.registerPropertyOnType(propName, this.syntacticScope);
registry.registerPropertyOnType(propName, this.functionScope);
registry.registerPropertyOnType(propName, this.bottomScope);
registry.registerPropertyOnType(propName, this.assertionFunctionsMap);
registry.registerPropertyOnType(propName, );
registry.registerPropertyOnType(propName, nodeType, objectType);
registry.registerPropertyOnType(propName, getprop, objectType);
registry.registerPropertyOnType(propName, rightType, objectType);
registry.registerPropertyOnType(propName, FUNCTION_LITERAL_UNDEFINED_THIS, objectType);
registry.registerPropertyOnType(propName, this.compiler, objectType);
registry.registerPropertyOnType(propName, this.reverseInterpreter, objectType);
registry.registerPropertyOnType(propName, this.syntacticScope, objectType);
registry.registerPropertyOnType(propName, this.functionScope, objectType);
registry.registerPropertyOnType(propName, this.bottomScope, objectType);
registry.registerPropertyOnType(propName, this.assertionFunctionsMap, objectType);
registry.registerPropertyOnType(propName, objectType, nodeType);
registry.registerPropertyOnType(propName, objectType, getprop);
registry.registerPropertyOnType(propName, objectType, rightType);
registry.registerPropertyOnType(propName, objectType, FUNCTION_LITERAL_UNDEFINED_THIS);
registry.registerPropertyOnType(propName, objectType, this.compiler);
registry.registerPropertyOnType(propName, objectType, this.reverseInterpreter);
registry.registerPropertyOnType(propName, objectType, this.syntacticScope);
registry.registerPropertyOnType(propName, objectType, this.functionScope);
registry.registerPropertyOnType(propName, objectType, this.bottomScope);
registry.registerPropertyOnType(propName, objectType, this.assertionFunctionsMap);
07:25:59.548 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:00.468 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:00.469 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:01.382 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:01.383 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:02.308 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:02.309 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:03.225 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:03.225 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:04.171 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:04.171 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:05.108 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:05.109 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:06.027 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:06.028 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:06.944 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:06.944 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:07.890 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:07.890 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:08.815 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:08.815 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:09.723 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:09.724 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:10.649 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:10.650 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:11.585 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:11.586 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:12.512 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:12.512 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:13.437 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:13.437 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:14.361 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:14.361 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:15.294 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:15.295 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:16.223 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:16.223 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:17.156 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:17.157 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:18.077 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:18.078 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:19.019 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:19.020 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:19.970 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:19.970 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:20.918 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:20.919 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:21.845 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:21.845 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:22.777 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:22.777 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:23.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:23.730 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:24.641 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:24.641 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:25.599 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:25.599 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:26.524 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:26.525 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:27.424 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:27.425 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:28.342 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:28.342 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:28.671 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:28.672 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:29.582 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:29.582 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:30.501 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:30.502 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:31.408 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:31.408 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:32.346 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:32.347 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:33.260 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:33.260 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:34.220 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:34.221 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:35.126 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:35.127 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:36.049 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:36.050 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:36.997 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:36.997 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:37.934 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:37.934 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:38.856 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:38.856 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:39.792 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:39.792 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:40.728 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:40.728 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:41.658 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:41.659 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:42.571 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:42.571 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:43.493 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:43.493 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:44.430 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:44.431 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:45.341 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:45.341 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:46.245 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:46.246 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:47.163 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (registry != null) {


}

if (propName != null) {


}

if (objectType != null) {


}

07:26:47.231 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:48.137 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:48.137 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:49.045 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:49.046 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:49.941 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (registry == null) {
    return;
}

if (registry == null) {
    throw new IllegalArgumentException("Empty variable: " + registry);
}

if (propName == null) {
    return;
}

if (propName == null) {
    throw new IllegalArgumentException("Empty variable: " + propName);
}

if (objectType == null) {
    return;
}

if (objectType == null) {
    throw new IllegalArgumentException("Empty variable: " + objectType);
}

07:26:49.942 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:50.842 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:50.843 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:51.756 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:51.757 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:52.663 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:52.663 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:53.590 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:53.591 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:54.501 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:54.501 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:55.458 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
registry.registerPropertyOnType(propName, objectType);
	objectType.defineInferredProperty(
                propName, rightType, getprop);
          } else {
            
null
07:26:55.460 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:56.378 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:26:56.379 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:57.299 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:57.299 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.TypeInference ===1252
07:26:57.363 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
return getNativeType(UNKNOWN_TYPE);
return getNativeType(var);
return getNativeType(qualifiedName);
return getNativeType(isLocallyInferred);
return getNativeType(propertyType);
return getNativeType(unknownType);
return getNativeType(objType);
return getNativeType(propName);
return getNativeType(n);
return getNativeType(scope);
return getNativeType(FUNCTION_LITERAL_UNDEFINED_THIS);
return getNativeType(this.compiler);
return getNativeType(this.registry);
return getNativeType(this.reverseInterpreter);
return getNativeType(this.syntacticScope);
return getNativeType(this.functionScope);
return getNativeType(this.bottomScope);
return getNativeType(this.assertionFunctionsMap);
return getNativeType();
return getNativeType(var, UNKNOWN_TYPE);
return getNativeType(qualifiedName, UNKNOWN_TYPE);
return getNativeType(isLocallyInferred, UNKNOWN_TYPE);
return getNativeType(propertyType, UNKNOWN_TYPE);
return getNativeType(unknownType, UNKNOWN_TYPE);
return getNativeType(objType, UNKNOWN_TYPE);
return getNativeType(propName, UNKNOWN_TYPE);
return getNativeType(n, UNKNOWN_TYPE);
return getNativeType(scope, UNKNOWN_TYPE);
return getNativeType(FUNCTION_LITERAL_UNDEFINED_THIS, UNKNOWN_TYPE);
return getNativeType(this.compiler, UNKNOWN_TYPE);
return getNativeType(this.registry, UNKNOWN_TYPE);
return getNativeType(this.reverseInterpreter, UNKNOWN_TYPE);
return getNativeType(this.syntacticScope, UNKNOWN_TYPE);
return getNativeType(this.functionScope, UNKNOWN_TYPE);
return getNativeType(this.bottomScope, UNKNOWN_TYPE);
return getNativeType(this.assertionFunctionsMap, UNKNOWN_TYPE);
return getNativeType(UNKNOWN_TYPE, var);
return getNativeType(UNKNOWN_TYPE, qualifiedName);
return getNativeType(UNKNOWN_TYPE, isLocallyInferred);
return getNativeType(UNKNOWN_TYPE, propertyType);
return getNativeType(UNKNOWN_TYPE, unknownType);
return getNativeType(UNKNOWN_TYPE, objType);
return getNativeType(UNKNOWN_TYPE, propName);
return getNativeType(UNKNOWN_TYPE, n);
return getNativeType(UNKNOWN_TYPE, scope);
return getNativeType(UNKNOWN_TYPE, FUNCTION_LITERAL_UNDEFINED_THIS);
return getNativeType(UNKNOWN_TYPE, this.compiler);
return getNativeType(UNKNOWN_TYPE, this.registry);
return getNativeType(UNKNOWN_TYPE, this.reverseInterpreter);
return getNativeType(UNKNOWN_TYPE, this.syntacticScope);
return getNativeType(UNKNOWN_TYPE, this.functionScope);
return getNativeType(UNKNOWN_TYPE, this.bottomScope);
return getNativeType(UNKNOWN_TYPE, this.assertionFunctionsMap);
07:26:57.365 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:58.271 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:58.272 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:26:59.210 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:26:59.211 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:00.117 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:00.117 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:01.024 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:01.025 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:01.952 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:01.952 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:02.862 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:02.863 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:03.836 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:03.836 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:04.780 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:04.781 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:05.695 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:05.696 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:06.621 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:06.621 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:07.561 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:07.561 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:08.503 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:08.503 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:09.426 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:09.426 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:10.356 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:10.357 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:11.284 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:11.285 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:12.200 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:12.200 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:13.122 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:13.122 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:14.059 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:14.060 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:14.985 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:14.986 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:15.934 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:15.934 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:16.842 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:16.843 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:17.767 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:17.768 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:18.717 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:18.717 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:19.698 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:19.699 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:20.611 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:20.612 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:21.536 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:21.537 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:22.449 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:22.450 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:23.390 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:23.390 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:24.342 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:24.343 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:25.265 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:25.265 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:26.189 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:26.189 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:27.107 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:27.108 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:28.028 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:28.029 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:28.943 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:28.943 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:29.865 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:29.865 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:30.848 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:30.848 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:31.776 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:31.777 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:32.708 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:32.709 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:33.629 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:33.629 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:34.544 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:34.545 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:35.483 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:35.483 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:36.423 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:36.424 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:37.358 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:37.358 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:38.286 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:38.286 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:39.211 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:39.211 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:40.149 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:40.149 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:41.074 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:41.074 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:41.984 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:41.985 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:42.904 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:42.904 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:43.843 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:43.843 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:44.781 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:44.782 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:45.713 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
return getJSType(UNKNOWN_TYPE);
return ensurePropertyDeclared(UNKNOWN_TYPE);
return isAddedAsNumber(UNKNOWN_TYPE);
return isUnflowable(UNKNOWN_TYPE);
07:27:45.714 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:46.636 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:46.637 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:47.585 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:47.585 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:48.566 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:48.566 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:49.482 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
return createInitialEstimateLattice();
return createEntryLattice();
07:27:49.483 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:50.409 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:50.409 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:51.318 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
return getNativeType(true, UNKNOWN_TYPE);
return getNativeType(false, UNKNOWN_TYPE);
return getNativeType(UNKNOWN_TYPE, true);
return getNativeType(UNKNOWN_TYPE, false);
07:27:51.319 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:52.231 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:52.232 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:53.146 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:53.146 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:54.061 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:54.061 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:54.972 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (UNKNOWN_TYPE != null) {


}

07:27:54.973 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:55.890 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (UNKNOWN_TYPE == null) {
    return null;
}

if (UNKNOWN_TYPE == null) {
    throw new IllegalArgumentException("Empty variable: " + UNKNOWN_TYPE);
}

07:27:55.891 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:56.840 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:56.840 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:57.764 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:27:57.765 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:58.671 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:27:58.671 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.TypeInference ===545
07:27:58.715 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
if (getprop.getFirstChild().isThis() &&
              getJSType(syntacticScope.getRootNode()).isConstructor()) {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          } else {
            registry.registerPropertyOnType(propName, objectType);
          }
if (getprop.getFirstChild().isThis() || getJSType(syntacticScope.getRootNode()).isConstructor()) {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          } else {
            registry.registerPropertyOnType(propName, objectType);
          }
07:27:58.716 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:27:59.660 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (getprop != null) {


}

if (syntacticScope != null) {


}

07:27:59.661 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:00.582 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:00.583 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:01.488 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (getprop == null) {
    return;
}

if (getprop == null) {
    throw new IllegalArgumentException("Empty variable: " + getprop);
}

if (syntacticScope == null) {
    return;
}

if (syntacticScope == null) {
    throw new IllegalArgumentException("Empty variable: " + syntacticScope);
}

07:28:01.489 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:02.390 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:02.390 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:03.337 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:03.338 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:04.257 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:04.258 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:05.196 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (getprop.getFirstChild().isThis() &&
              getJSType(syntacticScope.getRootNode()).isConstructor()) {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          } else {
            registry.registerPropertyOnType(propName, objectType);
          }
	if ("prototype".equals(propName)) {
            objectType.defineDeclaredProperty(
                propName, rightType, getprop);
          } else {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          }
        } else {
          
null
07:28:05.198 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:06.117 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:28:06.118 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:07.054 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:07.055 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.jscomp.TypeInference ===535
07:28:07.095 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
if (objectType.hasProperty(propName) ||
            !objectType.isInstanceType()) {
          if ("prototype".equals(propName)) {
            objectType.defineDeclaredProperty(
                propName, rightType, getprop);
          } else {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          }
        } else {
          if (getprop.getFirstChild().isThis() &&
              getJSType(syntacticScope.getRootNode()).isConstructor()) {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          } else {
            registry.registerPropertyOnType(propName, objectType);
          }
        }
if (objectType.hasProperty(propName) && !objectType.isInstanceType()) {
          if ("prototype".equals(propName)) {
            objectType.defineDeclaredProperty(
                propName, rightType, getprop);
          } else {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          }
        } else {
          if (getprop.getFirstChild().isThis() &&
              getJSType(syntacticScope.getRootNode()).isConstructor()) {
            objectType.defineInferredProperty(
                propName, rightType, getprop);
          } else {
            registry.registerPropertyOnType(propName, objectType);
          }
        }
07:28:07.096 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:08.032 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (objectType != null) {


}

if (propName != null) {


}

if (objectType != null) {


}

07:28:08.034 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:08.965 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:08.966 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:09.921 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:09.921 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:10.831 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
if (objectType == null) {
    return;
}

if (objectType == null) {
    throw new IllegalArgumentException("Empty variable: " + objectType);
}

if (propName == null) {
    return;
}

if (propName == null) {
    throw new IllegalArgumentException("Empty variable: " + propName);
}

if (objectType == null) {
    return;
}

if (objectType == null) {
    throw new IllegalArgumentException("Empty variable: " + objectType);
}

07:28:10.832 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:11.751 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:11.751 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:12.750 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:12.750 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:13.671 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:13.672 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:14.596 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:14.597 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:15.521 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:15.522 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:16.461 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 

07:28:16.462 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Compiling
07:28:17.387 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - Closure-11 ---Fixer: fix fail because of failed compiling! 
07:28:17.388 [main] DEBUG edu.lu.uni.serval.bug.fixer.AbstractFixer - com.google.javascript.rhino.jstype.FunctionType ===66
07:28:17.501 [main] INFO edu.lu.uni.serval.bug.fixer.AbstractFixer - Suspicious Code: 
public class FunctionType extends PrototypeObjectType {
  private static final long serialVersionUID = 1L;

  private enum Kind {
    ORDINARY,
    CONSTRUCTOR,
    INTERFACE
  }

  // relevant only for constructors
  private enum PropAccess { ANY, STRUCT, DICT }

  /**
   * {@code [[Call]]} property.
   */
  private ArrowType call;

  /**
   * The {@code prototype} property. This field is lazily initialized by
   * {@code #getPrototype()}. The most important reason for lazily
   * initializing this field is that there are cycles in the native types
   * graph, so some prototypes must temporarily be {@code null} during
   * the construction of the graph.
   *
   * If non-null, the type must be a PrototypeObjectType.
   */
  private Property prototypeSlot;

  /**
   * Whether a function is a constructor, an interface, or just an ordinary
   * function.
   */
  private final Kind kind;

  /**
   * Whether the instances are structs, dicts, or unrestricted.
   */
  private PropAccess propAccess;

  /**
   * The type of {@code this} in the scope of this function.
   */
  private ObjectType typeOfThis;

  /**
   * The function node which this type represents. It may be {@code null}.
   */
  private Node source;

  /**
   * The interfaces directly implemented by this function (for constructors)
   * It is only relevant for constructors. May not be {@code null}.
   */
  private List<ObjectType> implementedInterfaces = ImmutableList.of();

  /**
   * The interfaces directly extended by this function (for interfaces)
   * It is only relevant for constructors. May not be {@code null}.
   */
  private List<ObjectType> extendedInterfaces = ImmutableList.of();

  /**
   * The types which are subtypes of this function. It is only relevant for
   * constructors and may be {@code null}.
   */
  private List<FunctionType> subTypes;

  /**
   * The template type name. May be {@code null}.
   */
  private final ImmutableList<String> templateTypeNames;

  /** Creates an instance for a function that might be a constructor. */
  FunctionType(JSTypeRegistry registry, String name, Node source,
               ArrowType arrowType, ObjectType typeOfThis,
               ImmutableList<String> templateTypeNames,
               boolean isConstructor, boolean nativeType) {
    super(registry, name,
        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),
        nativeType);
    setPrettyPrint(true);

    Preconditions.checkArgument(source == null ||
        Token.FUNCTION == source.getType());
    Preconditions.checkNotNull(arrowType);
    this.source = source;
    if (isConstructor) {
      this.kind = Kind.CONSTRUCTOR;
      this.propAccess = PropAccess.ANY;
      this.typeOfThis = typeOfThis != null ?
          typeOfThis : new InstanceObjectType(registry, this, nativeType);
    } else {
      this.kind = Kind.ORDINARY;
      this.typeOfThis = typeOfThis != null ?
          typeOfThis :
          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);
    }
    this.call = arrowType;
    this.templateTypeNames = templateTypeNames != null
        ? templateTypeNames : ImmutableList.<String>of();
  }

  /** Creates an instance for a function that is an interface. */
  private FunctionType(JSTypeRegistry registry, String name, Node source) {
    super(registry, name,
        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE));
    setPrettyPrint(true);

    Preconditions.checkArgument(source == null ||
        Token.FUNCTION == source.getType());
    Preconditions.checkArgument(name != null);
    this.source = source;
    this.call = new ArrowType(registry, new Node(Token.PARAM_LIST), null);
    this.kind = Kind.INTERFACE;
    this.typeOfThis = new InstanceObjectType(registry, this);
    this.templateTypeNames = ImmutableList.of();
  }

  /** Creates an instance for a function that is an interface. */
  static FunctionType forInterface(
      JSTypeRegistry registry, String name, Node source) {
    return new FunctionType(registry, name, source);
  }

  @Override
  public boolean isInstanceType() {
    // The universal constructor is its own instance, bizarrely.
    return isEquivalentTo(registry.getNativeType(U2U_CONSTRUCTOR_TYPE));
  }

  @Override
  public boolean isConstructor() {
    return kind == Kind.CONSTRUCTOR;
  }

  @Override
  public boolean isInterface() {
    return kind == Kind.INTERFACE;
  }

  @Override
  public boolean isOrdinaryFunction() {
    return kind == Kind.ORDINARY;
  }

  /**
   * When a class B inherits from A and A is annotated as a struct, then B
   * automatically gets the annotation, even if B's constructor is not
   * explicitly annotated.
   */
  public boolean makesStructs() {
    if (!isConstructor()) {
      return false;
    }
    if (propAccess == PropAccess.STRUCT) {
      return true;
    }
    FunctionType superc = getSuperClassConstructor();
    if (superc != null && superc.makesStructs()) {
      setStruct();
      return true;
    }
    return false;
  }

  /**
   * When a class B inherits from A and A is annotated as a dict, then B
   * automatically gets the annotation, even if B's constructor is not
   * explicitly annotated.
   */
  public boolean makesDicts() {
    if (!isConstructor()) {
      return false;
    }
    if (propAccess == PropAccess.DICT) {
      return true;
    }
    FunctionType superc = getSuperClassConstructor();
    if (superc != null && superc.makesDicts()) {
      setDict();
      return true;
    }
    return false;
  }

  public void setStruct() {
    propAccess = PropAccess.STRUCT;
  }

  public void setDict() {
    propAccess = PropAccess.DICT;
  }

  @Override
  public FunctionType toMaybeFunctionType() {
    return this;
  }

  @Override
  public boolean canBeCalled() {
    return true;
  }

  public boolean hasImplementedInterfaces() {
    if (!implementedInterfaces.isEmpty()){
      return true;
    }
    FunctionType superCtor = isConstructor() ?
        getSuperClassConstructor() : null;
    if (superCtor != null) {
      return superCtor.hasImplementedInterfaces();
    }
    return false;
  }

  public Iterable<Node> getParameters() {
    Node n = getParametersNode();
    if (n != null) {
      return n.children();
    } else {
      return Collections.emptySet();
    }
  }

  /** Gets an LP node that contains all params. May be null. */
  public Node getParametersNode() {
    return call.parameters;
  }

  /** Gets the minimum number of arguments that this function requires. */
  public int getMinArguments() {
    // NOTE(nicksantos): There are some native functions that have optional
    // parameters before required parameters. This algorithm finds the position
    // of the last required parameter.
    int i = 0;
    int min = 0;
    for (Node n : getParameters()) {
      i++;
      if (!n.isOptionalArg() && !n.isVarArgs()) {
        min = i;
      }
    }
    return min;
  }

  /**
   * Gets the maximum number of arguments that this function requires,
   * or Integer.MAX_VALUE if this is a variable argument function.
   */
  public int getMaxArguments() {
    Node params = getParametersNode();
    if (params != null) {
      Node lastParam = params.getLastChild();
      if (lastParam == null || !lastParam.isVarArgs()) {
        return params.getChildCount();
      }
    }

    return Integer.MAX_VALUE;
  }

  public JSType getReturnType() {
    return call.returnType;
  }

  public boolean isReturnTypeInferred() {
    return call.returnTypeInferred;
  }

  /** Gets the internal arrow type. For use by subclasses only. */
  ArrowType getInternalArrowType() {
    return call;
  }

  @Override
  public Property getSlot(String name) {
    if ("prototype".equals(name)) {
      // Lazy initialization of the prototype field.
      getPrototype();
      return prototypeSlot;
    } else {
      return super.getSlot(name);
    }
  }

  /**
   * Includes the prototype iff someone has created it. We do not want
   * to expose the prototype for ordinary functions.
   */
  @Override
  public Set<String> getOwnPropertyNames() {
    if (prototypeSlot == null) {
      return super.getOwnPropertyNames();
    } else {
      Set<String> names = Sets.newHashSet("prototype");
      names.addAll(super.getOwnPropertyNames());
      return names;
    }
  }

  /**
   * Gets the {@code prototype} property of this function type. This is
   * equivalent to {@code (ObjectType) getPropertyType("prototype")}.
   */
  public ObjectType getPrototype() {
    // lazy initialization of the prototype field
    if (prototypeSlot == null) {
      String refName = getReferenceName();
      if (refName == null) {
        // Someone is trying to access the prototype of a structural function.
        // We don't want to give real properties to this prototype, because
        // then it would propagate to all structural functions.
        setPrototypeNoCheck(
           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),
           null);
      } else {
        setPrototype(
            new PrototypeObjectType(
                registry,
                this.getReferenceName() + ".prototype",
                registry.getNativeObjectType(OBJECT_TYPE),
                isNativeObjectType()),
            null);
      }
    }
    return (ObjectType) prototypeSlot.getType();
  }

  /**
   * Sets the prototype, creating the prototype object from the given
   * base type.
   * @param baseType The base type.
   */
  public void setPrototypeBasedOn(ObjectType baseType) {
    setPrototypeBasedOn(baseType, null);
  }

  void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {
    // This is a bit weird. We need to successfully handle these
    // two cases:
    // Foo.prototype = new Bar();
    // and
    // Foo.prototype = {baz: 3};
    // In the first case, we do not want new properties to get
    // added to Bar. In the second case, we do want new properties
    // to get added to the type of the anonymous object.
    //
    // We handle this by breaking it into two cases:
    //
    // In the first case, we create a new PrototypeObjectType and set
    // its implicit prototype to the type being assigned. This ensures
    // that Bar will not get any properties of Foo.prototype, but properties
    // later assigned to Bar will get inherited properly.
    //
    // In the second case, we just use the anonymous object as the prototype.
    if (baseType.hasReferenceName() ||
        isNativeObjectType() ||
        baseType.isFunctionPrototypeType()) {

      baseType = new PrototypeObjectType(
          registry, this.getReferenceName() + ".prototype", baseType);
    }
    setPrototype(baseType, propertyNode);
  }

  /**
   * Sets the prototype.
   * @param prototype the prototype. If this value is {@code null} it will
   *        silently be discarded.
   */
  boolean setPrototype(ObjectType prototype, Node propertyNode) {
    if (prototype == null) {
      return false;
    }
    // getInstanceType fails if the function is not a constructor
    if (isConstructor() && prototype == getInstanceType()) {
      return false;
    }
    return setPrototypeNoCheck(prototype, propertyNode);
  }

  /** Set the prototype without doing any sanity checks. */
  private boolean setPrototypeNoCheck(ObjectType prototype, Node propertyNode) {
    ObjectType oldPrototype = prototypeSlot == null
        ? null : (ObjectType) prototypeSlot.getType();
    boolean replacedPrototype = oldPrototype != null;

    this.prototypeSlot = new Property("prototype", prototype, true,
        propertyNode == null ? source : propertyNode);
    prototype.setOwnerFunction(this);

    if (oldPrototype != null) {
      // Disassociating the old prototype makes this easier to debug--
      // we don't have to worry about two prototypes running around.
      oldPrototype.setOwnerFunction(null);
    }

    if (isConstructor() || isInterface()) {
      FunctionType superClass = getSuperClassConstructor();
      if (superClass != null) {
        superClass.addSubType(this);
      }

      if (isInterface()) {
        for (ObjectType interfaceType : getExtendedInterfaces()) {
          if (interfaceType.getConstructor() != null) {
            interfaceType.getConstructor().addSubType(this);
          }
        }
      }
    }

    if (replacedPrototype) {
      clearCachedValues();
    }

    return true;
  }

  /**
   * Returns all interfaces implemented by a class or its superclass and any
   * superclasses for any of those interfaces. If this is called before all
   * types are resolved, it may return an incomplete set.
   */
  public Iterable<ObjectType> getAllImplementedInterfaces() {
    // Store them in a linked hash set, so that the compile job is
    // deterministic.
    Set<ObjectType> interfaces = Sets.newLinkedHashSet();

    for (ObjectType type : getImplementedInterfaces()) {
      addRelatedInterfaces(type, interfaces);
    }
    return interfaces;
  }

  private void addRelatedInterfaces(ObjectType instance, Set<ObjectType> set) {
    FunctionType constructor = instance.getConstructor();
    if (constructor != null) {
      if (!constructor.isInterface()) {
        return;
      }

      set.add(instance);

      for (ObjectType interfaceType : instance.getCtorExtendedInterfaces()) {
        addRelatedInterfaces(interfaceType, set);
      }
    }
  }

  /** Returns interfaces implemented directly by a class or its superclass. */
  public Iterable<ObjectType> getImplementedInterfaces() {
    FunctionType superCtor = isConstructor() ?
        getSuperClassConstructor() : null;
    if (superCtor == null) {
      return implementedInterfaces;
    } else {
      return Iterables.concat(
          implementedInterfaces, superCtor.getImplementedInterfaces());
    }
  }

  /** Returns interfaces directly implemented by the class. */
  public Iterable<ObjectType> getOwnImplementedInterfaces() {
    return implementedInterfaces;
  }

  public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {
    // Records this type for each implemented interface.
    for (ObjectType type : implementedInterfaces) {
      registry.registerTypeImplementingInterface(this, type);
    }
    this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);
  }

  /**
   * Returns all extended interfaces declared by an interfaces or its super-
   * interfaces. If this is called before all types are resolved, it may return
   * an incomplete set.
   */
  public Iterable<ObjectType> getAllExtendedInterfaces() {
    // Store them in a linked hash set, so that the compile job is
    // deterministic.
    Set<ObjectType> extendedInterfaces = Sets.newLinkedHashSet();

    for (ObjectType interfaceType : getExtendedInterfaces()) {
      addRelatedExtendedInterfaces(interfaceType, extendedInterfaces);
    }
    return extendedInterfaces;
  }

  private void addRelatedExtendedInterfaces(ObjectType instance,
      Set<ObjectType> set) {
    FunctionType constructor = instance.getConstructor();
    if (constructor != null) {
      set.add(instance);

      for (ObjectType interfaceType : constructor.getExtendedInterfaces()) {
        addRelatedExtendedInterfaces(interfaceType, set);
      }
    }
  }

  /** Returns interfaces directly extended by an interface */
  public Iterable<ObjectType> getExtendedInterfaces() {
    return extendedInterfaces;
  }

  /** Returns the number of interfaces directly extended by an interface */
  public int getExtendedInterfacesCount() {
    return extendedInterfaces.size();
  }

  public void setExtendedInterfaces(List<ObjectType> extendedInterfaces)
    throws UnsupportedOperationException {
    if (isInterface()) {
      this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces);
    } else {
      throw new UnsupportedOperationException();
    }
  }

  @Override
  public JSType getPropertyType(String name) {
    if (!hasOwnProperty(name)) {
      // Define the "call", "apply", and "bind" functions lazily.
      boolean isCall = "call".equals(name);
      boolean isBind = "bind".equals(name);
      if (isCall || isBind) {
        defineDeclaredProperty(name, getCallOrBindSignature(isCall), source);
      } else if ("apply".equals(name)) {
        // Define the "apply" function lazily.
        FunctionParamBuilder builder = new FunctionParamBuilder(registry);

        // ECMA-262 says that apply's second argument must be an Array
        // or an arguments object. We don't model the arguments object,
        // so let's just be forgiving for now.
        // TODO(nicksantos): Model the Arguments object.
        builder.addOptionalParams(
            registry.createNullableType(getTypeOfThis()),
            registry.createNullableType(
                registry.getNativeType(JSTypeNative.OBJECT_TYPE)));

        defineDeclaredProperty(name,
            new FunctionBuilder(registry)
            .withParams(builder)
            .withReturnType(getReturnType())
            .build(),
            source);
      }
    }

    return super.getPropertyType(name);
  }

  /**
   * Get the return value of calling "bind" on this function
   * with the specified number of arguments.
   *
   * If -1 is passed, then we will return a result that accepts
   * any parameters.
   */
  public FunctionType getBindReturnType(int argsToBind) {
    FunctionBuilder builder = new FunctionBuilder(registry)
        .withReturnType(getReturnType());
    if (argsToBind >= 0) {
      Node origParams = getParametersNode();
      if (origParams != null) {
        Node params = origParams.cloneTree();
        for (int i = 1; i < argsToBind && params.getFirstChild() != null; i++) {
          if (params.getFirstChild().isVarArgs()) {
            break;
          }
          params.removeFirstChild();
        }
        builder.withParamsNode(params);
      }
    }
    return builder.build();
  }

  /**
   * Notice that "call" and "bind" have the same argument signature,
   * except that all the arguments of "bind" (except the first)
   * are optional.
   */
  private FunctionType getCallOrBindSignature(boolean isCall) {
    boolean isBind = !isCall;
    FunctionBuilder builder = new FunctionBuilder(registry)
        .withReturnType(isCall ? getReturnType() : getBindReturnType(-1));

    Node origParams = getParametersNode();
    if (origParams != null) {
      Node params = origParams.cloneTree();

      Node thisTypeNode = Node.newString(Token.NAME, "thisType");
      thisTypeNode.setJSType(
          registry.createOptionalNullableType(getTypeOfThis()));
      params.addChildToFront(thisTypeNode);
      thisTypeNode.setOptionalArg(isCall);

      if (isBind) {
        // The arguments of bind() are unique in that they are all
        // optional but not undefinable.
        for (Node current = thisTypeNode.getNext();
             current != null; current = current.getNext()) {
          current.setOptionalArg(true);
        }
      }

      builder.withParamsNode(params);
    }

    return builder.build();
  }

  @Override
  boolean defineProperty(String name, JSType type,
      boolean inferred, Node propertyNode) {
    if ("prototype".equals(name)) {
      ObjectType objType = type.toObjectType();
      if (objType != null) {
        if (prototypeSlot != null &&
            objType.isEquivalentTo(prototypeSlot.getType())) {
          return true;
        }
        this.setPrototypeBasedOn(objType, propertyNode);
        return true;
      } else {
        return false;
      }
    }
    return super.defineProperty(name, type, inferred, propertyNode);
  }

  /**
   * Computes the supremum or infimum of two functions.
   * Because sup() and inf() share a lot of logic for functions, we use
   * a single helper.
   * @param leastSuper If true, compute the supremum of {@code this} with
   *     {@code that}. Otherwise, compute the infimum.
   * @return The least supertype or greatest subtype.
   */
  FunctionType supAndInfHelper(FunctionType that, boolean leastSuper) {
    // NOTE(nicksantos): When we remove the unknown type, the function types
    // form a lattice with the universal constructor at the top of the lattice,
    // and the LEAST_FUNCTION_TYPE type at the bottom of the lattice.
    //
    // When we introduce the unknown type, it's much more difficult to make
    // heads or tails of the partial ordering of types, because there's no
    // clear hierarchy between the different components (parameter types and
    // return types) in the ArrowType.
    //
    // Rather than make the situation more complicated by introducing new
    // types (like unions of functions), we just fallback on the simpler
    // approach of getting things right at the top and the bottom of the
    // lattice.
    //
    // If there are unknown parameters or return types making things
    // ambiguous, then sup(A, B) is always the top function type, and
    // inf(A, B) is always the bottom function type.
    Preconditions.checkNotNull(that);

    if (isEquivalentTo(that)) {
      return this;
    }

    // If these are ordinary functions, then merge them.
    // Don't do this if any of the params/return
    // values are unknown, because then there will be cycles in
    // their local lattice and they will merge in weird ways.
    if (isOrdinaryFunction() && that.isOrdinaryFunction() &&
        !this.call.hasUnknownParamsOrReturn() &&
        !that.call.hasUnknownParamsOrReturn()) {

      // Check for the degenerate case, but double check
      // that there's not a cycle.
      boolean isSubtypeOfThat = this.isSubtype(that);
      boolean isSubtypeOfThis = that.isSubtype(this);
      if (isSubtypeOfThat && !isSubtypeOfThis) {
        return leastSuper ? that : this;
      } else if (isSubtypeOfThis && !isSubtypeOfThat) {
        return leastSuper ? this : that;
      }

      // Merge the two functions component-wise.
      FunctionType merged = tryMergeFunctionPiecewise(that, leastSuper);
      if (merged != null) {
        return merged;
      }
    }

    // The function instance type is a special case
    // that lives above the rest of the lattice.
    JSType functionInstance = registry.getNativeType(
        JSTypeNative.FUNCTION_INSTANCE_TYPE);
    if (functionInstance.isEquivalentTo(that)) {
      return leastSuper ? that : this;
    } else if (functionInstance.isEquivalentTo(this)) {
      return leastSuper ? this : that;
    }

    // In theory, we should be using the GREATEST_FUNCTION_TYPE as the
    // greatest function. In practice, we don't because it's way too
    // broad. The greatest function takes var_args None parameters, which
    // means that all parameters register a type warning.
    //
    // Instead, we use the U2U ctor type, which has unknown type args.
    FunctionType greatestFn =
        registry.getNativeFunctionType(JSTypeNative.U2U_CONSTRUCTOR_TYPE);
    FunctionType leastFn =
        registry.getNativeFunctionType(JSTypeNative.LEAST_FUNCTION_TYPE);
    return leastSuper ? greatestFn : leastFn;
  }

  /**
   * Try to get the sup/inf of two functions by looking at the
   * piecewise components.
   */
  private FunctionType tryMergeFunctionPiecewise(
      FunctionType other, boolean leastSuper) {
    Node newParamsNode = null;
    if (call.hasEqualParameters(other.call)) {
      newParamsNode = call.parameters;
    } else {
      // If the parameters are not equal, don't try to merge them.
      // Someday, we should try to merge the individual params.
      return null;
    }

    JSType newReturnType = leastSuper ?
        call.returnType.getLeastSupertype(other.call.returnType) :
        call.returnType.getGreatestSubtype(other.call.returnType);

    ObjectType newTypeOfThis = null;
    if (isEquivalent(typeOfThis, other.typeOfThis)) {
      newTypeOfThis = typeOfThis;
    } else {
      JSType maybeNewTypeOfThis = leastSuper ?
          typeOfThis.getLeastSupertype(other.typeOfThis) :
          typeOfThis.getGreatestSubtype(other.typeOfThis);
      if (maybeNewTypeOfThis instanceof ObjectType) {
        newTypeOfThis = (ObjectType) maybeNewTypeOfThis;
      } else {
        newTypeOfThis = leastSuper ?
            registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) :
            registry.getNativeObjectType(JSTypeNative.NO_OBJECT_TYPE);
      }
    }

    boolean newReturnTypeInferred =
        call.returnTypeInferred || other.call.returnTypeInferred;

    return new FunctionType(
        registry, null, null,
        new ArrowType(
            registry, newParamsNode, newReturnType, newReturnTypeInferred),
        newTypeOfThis, null, false, false);
  }

  /**
   * Given a constructor or an interface type, get its superclass constructor
   * or {@code null} if none exists.
   */
  public FunctionType getSuperClassConstructor() {
    Preconditions.checkArgument(isConstructor() || isInterface());
    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();
    if (maybeSuperInstanceType == null) {
      return null;
    }
    return maybeSuperInstanceType.getConstructor();
  }

  /**
   * Given an interface and a property, finds the top-most super interface
   * that has the property defined (including this interface).
   */
  public static ObjectType getTopDefiningInterface(ObjectType type,
      String propertyName) {
    ObjectType foundType = null;
    if (type.hasProperty(propertyName)) {
      foundType = type;
    }
    for (ObjectType interfaceType : type.getCtorExtendedInterfaces()) {
      if (interfaceType.hasProperty(propertyName)) {
        foundType = getTopDefiningInterface(interfaceType, propertyName);
      }
    }
    return foundType;
  }

  /**
   * Given a constructor or an interface type and a property, finds the
   * top-most superclass that has the property defined (including this
   * constructor).
   */
  public ObjectType getTopMostDefiningType(String propertyName) {
    Preconditions.checkState(isConstructor() || isInterface());
    Preconditions.checkArgument(getInstanceType().hasProperty(propertyName));
    FunctionType ctor = this;

    if (isInterface()) {
      return getTopDefiningInterface(this.getInstanceType(), propertyName);
    }

    ObjectType topInstanceType = null;
    do {
      topInstanceType = ctor.getInstanceType();
      ctor = ctor.getSuperClassConstructor();
    } while (ctor != null
        && ctor.getPrototype().hasProperty(propertyName));

    return topInstanceType;
  }

  /**
   * Two function types are equal if their signatures match. Since they don't
   * have signatures, two interfaces are equal if their names match.
   */
  @Override
  public boolean isEquivalentTo(JSType otherType) {
    FunctionType that =
        JSType.toMaybeFunctionType(otherType);
    if (that == null) {
      return false;
    }
    if (this.isConstructor()) {
      if (that.isConstructor()) {
        return this == that;
      }
      return false;
    }
    if (this.isInterface()) {
      if (that.isInterface()) {
        return this.getReferenceName().equals(that.getReferenceName());
      }
      return false;
    }
    if (that.isInterface()) {
      return false;
    }
    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&
        this.call.isEquivalentTo(that.call);
  }

  @Override
  public int hashCode() {
    return isInterface() ? getReferenceName().hashCode() : call.hashCode();
  }

  public boolean hasEqualCallType(FunctionType otherType) {
    return this.call.isEquivalentTo(otherType.call);
  }

  /**
   * Informally, a function is represented by
   * {@code function (params): returnType} where the {@code params} is a comma
   * separated list of types, the first one being a special
   * {@code this:T} if the function expects a known type for {@code this}.
   */
  @Override
  String toStringHelper(boolean forAnnotations) {
    if (!isPrettyPrint() ||
        this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
      return "Function";
    }

    setPrettyPrint(false);

    StringBuilder b = new StringBuilder(32);
    b.append("function (");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !(typeOfThis instanceof UnknownType);
    if (hasKnownTypeOfThis) {
      if (isConstructor()) {
        b.append("new:");
      } else {
        b.append("this:");
      }
      b.append(typeOfThis.toStringHelper(forAnnotations));
    }
    if (paramNum > 0) {
      if (hasKnownTypeOfThis) {
        b.append(", ");
      }
      Node p = call.parameters.getFirstChild();
      appendArgString(b, p, forAnnotations);

      p = p.getNext();
      while (p != null) {
        b.append(", ");
        appendArgString(b, p, forAnnotations);
        p = p.getNext();
      }
    }
    b.append("): ");
    b.append(call.returnType.toStringHelper(forAnnotations));

    setPrettyPrint(true);
    return b.toString();
  }

  private void appendArgString(
      StringBuilder b, Node p, boolean forAnnotations) {
    if (p.isVarArgs()) {
      appendVarArgsString(b, p.getJSType(), forAnnotations);
    } else if (p.isOptionalArg()) {
      appendOptionalArgString(b, p.getJSType(), forAnnotations);
    } else {
      b.append(p.getJSType().toStringHelper(forAnnotations));
    }
  }

  /** Gets the string representation of a var args param. */
  private void appendVarArgsString(StringBuilder builder, JSType paramType,
      boolean forAnnotations) {
    if (paramType.isUnionType()) {
      // Remove the optionality from the var arg.
      paramType = paramType.toMaybeUnionType().getRestrictedUnion(
          registry.getNativeType(JSTypeNative.VOID_TYPE));
    }
    builder.append("...[").append(
        paramType.toStringHelper(forAnnotations)).append("]");
  }

  /** Gets the string representation of an optional param. */
  private void appendOptionalArgString(
      StringBuilder builder, JSType paramType, boolean forAnnotations) {
    if (paramType.isUnionType()) {
      // Remove the optionality from the var arg.
      paramType = paramType.toMaybeUnionType().getRestrictedUnion(
          registry.getNativeType(JSTypeNative.VOID_TYPE));
    }
    builder.append(paramType.toStringHelper(forAnnotations)).append("=");
  }

  /**
   * A function is a subtype of another if their call methods are related via
   * subtyping and {@code this} is a subtype of {@code that} with regard to
   * the prototype chain.
   */
  @Override
  public boolean isSubtype(JSType that) {
    if (JSType.isSubtypeHelper(this, that)) {
      return true;
    }

    if (that.isFunctionType()) {
      FunctionType other = that.toMaybeFunctionType();
      if (other.isInterface()) {
        // Any function can be assigned to an interface function.
        return true;
      }
      if (this.isInterface()) {
        // An interface function cannot be assigned to anything.
        return false;
      }
      // If functionA is a subtype of functionB, then their "this" types
      // should be contravariant. However, this causes problems because
      // of the way we enforce overrides. Because function(this:SubFoo)
      // is not a subtype of function(this:Foo), our override check treats
      // this as an error. It also screws up out standard method
      // for aliasing constructors. Let's punt on all this for now.
      // TODO(nicksantos): fix this.
      boolean treatThisTypesAsCovariant =
        // If either one of these is a ctor, skip 'this' checking.
        this.isConstructor() || other.isConstructor() ||

        // An interface 'this'-type is non-restrictive.
        // In practical terms, if C implements I, and I has a method m,
        // then any m doesn't necessarily have to C#m's 'this'
        // type doesn't need to match I.
        (other.typeOfThis.getConstructor() != null &&
             other.typeOfThis.getConstructor().isInterface()) ||

        // If one of the 'this' types is covariant of the other,
        // then we'll treat them as covariant (see comment above).
        other.typeOfThis.isSubtype(this.typeOfThis) ||
        this.typeOfThis.isSubtype(other.typeOfThis);
      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);
    }

    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);
  }

  @Override
  public <T> T visit(Visitor<T> visitor) {
    return visitor.caseFunctionType(this);
  }

  /**
   * Gets the type of instance of this function.
   * @throws IllegalStateException if this function is not a constructor
   *         (see {@link #isConstructor()}).
   */
  public ObjectType getInstanceType() {
    Preconditions.checkState(hasInstanceType());
    return typeOfThis;
  }

  /**
   * Sets the instance type. This should only be used for special
   * native types.
   */
  void setInstanceType(ObjectType instanceType) {
    typeOfThis = instanceType;
  }

  /**
   * Returns whether this function type has an instance type.
   */
  public boolean hasInstanceType() {
    return isConstructor() || isInterface();
  }

  /**
   * Gets the type of {@code this} in this function.
   */
  @Override
  public ObjectType getTypeOfThis() {
    return typeOfThis.isNoObjectType() ?
        registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE) : typeOfThis;
  }

  /**
   * Gets the source node or null if this is an unknown function.
   */
  public Node getSource() {
    return source;
  }

  /**
   * Sets the source node.
   */
  public void setSource(Node source) {
    if (prototypeSlot != null) {
      // NOTE(bashir): On one hand when source is null we want to drop any
      // references to old nodes retained in prototypeSlot. On the other hand
      // we cannot simply drop prototypeSlot, so we retain all information
      // except the propertyNode for which we use an approximation! These
      // details mostly matter in hot-swap passes.
      if (source == null || prototypeSlot.getNode() == null) {
        prototypeSlot = new Property(prototypeSlot.getName(),
            prototypeSlot.getType(), prototypeSlot.isTypeInferred(), source);
      }
    }
    this.source = source;
  }

  /** Adds a type to the list of subtypes for this type. */
  private void addSubType(FunctionType subType) {
    if (subTypes == null) {
      subTypes = Lists.newArrayList();
    }
    subTypes.add(subType);
  }

  @Override
  public void clearCachedValues() {
    super.clearCachedValues();

    if (subTypes != null) {
      for (FunctionType subType : subTypes) {
        subType.clearCachedValues();
      }
    }

    if (!isNativeObjectType()) {
      if (hasInstanceType()) {
        getInstanceType().clearCachedValues();
      }

      if (prototypeSlot != null) {
        ((ObjectType) prototypeSlot.getType()).clearCachedValues();
      }
    }
  }

  /**
   * Returns a list of types that are subtypes of this type. This is only valid
   * for constructor functions, and may be null. This allows a downward
   * traversal of the subtype graph.
   */
  public List<FunctionType> getSubTypes() {
    return subTypes;
  }

  @Override
  public boolean hasCachedValues() {
    return prototypeSlot != null || super.hasCachedValues();
  }

  /**
   * Gets the template type name.
   */
  public ImmutableList<String> getTemplateTypeNames() {
    return templateTypeNames;
  }

  @Override
  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {
    setResolvedTypeInternal(this);

    call = (ArrowType) safeResolve(call, t, scope);
    if (prototypeSlot != null) {
      prototypeSlot.setType(
          safeResolve(prototypeSlot.getType(), t, scope));
    }

    // Warning about typeOfThis if it doesn't resolve to an ObjectType
    // is handled further upstream.
    //
    // TODO(nicksantos): Handle this correctly if we have a UnionType.
    //
    // TODO(nicksantos): In ES3, the run-time coerces "null" to the global
    // activation object. In ES5, it leaves it as null. Just punt on this
    // issue for now by coercing out null. This is complicated by the
    // fact that when most people write @this {Foo}, they really don't
    // mean "nullable Foo". For certain tags (like @extends) we de-nullify
    // the name for them.
    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);
    if (maybeTypeOfThis != null) {
      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();
    }
    if (maybeTypeOfThis instanceof ObjectType) {
      typeOfThis = (ObjectType) maybeTypeOfThis;
    }

    boolean changed = false;
    ImmutableList.Builder<ObjectType> resolvedInterfaces =
        ImmutableList.builder();
    for (ObjectType iface : implementedInterfaces) {
      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);
      resolvedInterfaces.add(resolvedIface);
      changed |= (resolvedIface != iface);
    }
    if (changed) {
      implementedInterfaces = resolvedInterfaces.build();
    }

    if (subTypes != null) {
      for (int i = 0; i < subTypes.size(); i++) {
        subTypes.set(
            i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope)));
      }
    }

    return super.resolveInternal(t, scope);
  }

  @Override
  public String toDebugHashCodeString() {
    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {
      return super.toDebugHashCodeString();
    }

    StringBuilder b = new StringBuilder(32);
    b.append("function (");
    int paramNum = call.parameters.getChildCount();
    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();
    if (hasKnownTypeOfThis) {
      b.append("this:");
      b.append(getDebugHashCodeStringOf(typeOfThis));
    }
    if (paramNum > 0) {
      if (hasKnownTypeOfThis) {
        b.append(", ");
      }
      Node p = call.parameters.getFirstChild();
      b.append(getDebugHashCodeStringOf(p.getJSType()));
      p = p.getNext();
      while (p != null) {
        b.append(", ");
        b.append(getDebugHashCodeStringOf(p.getJSType()));
        p = p.getNext();
      }
    }
    b.append(")");
    b.append(": ");
    b.append(getDebugHashCodeStringOf(call.returnType));
    return b.toString();
  }

  private String getDebugHashCodeStringOf(JSType type) {
    if (type == this) {
      return "me";
    } else {
      return type.toDebugHashCodeString();
    }
  }

  /** Create a new constructor with the parameters and return type stripped. */
  public FunctionType cloneWithoutArrowType() {
    FunctionType result = new FunctionType(
        registry, getReferenceName(), source,
        registry.createArrowType(null, null), getInstanceType(),
        null, true, false);
    result.setPrototypeBasedOn(getInstanceType());
    return result;
  }

  @Override
  public boolean hasAnyTemplateInternal() {
    return !getTemplateTypeNames().isEmpty()
        || typeOfThis.hasAnyTemplate()
        || call.hasAnyTemplate();
  }
}
